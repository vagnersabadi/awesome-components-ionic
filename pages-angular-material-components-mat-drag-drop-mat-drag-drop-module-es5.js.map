{"version":3,"sources":["pages-angular-material-components-mat-drag-drop-mat-drag-drop-module-es5.js","webpack:///node_modules/@angular/cdk/esm2015/bidi.js","webpack:///node_modules/@angular/cdk/esm2015/drag-drop.js","webpack:///src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.page.html","webpack:///src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.module.ts","webpack:///src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.page.scss","webpack:///src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.page.ts"],"names":[],"mappings":"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","file":"x","sourcesContent":["(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[\"pages-angular-material-components-mat-drag-drop-mat-drag-drop-module\"],{\n\n/***/ \"./node_modules/@angular/cdk/esm2015/bidi.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/@angular/cdk/esm2015/bidi.js ***!\n  \\***************************************************/\n/*! exports provided: Directionality, DIR_DOCUMENT, Dir, BidiModule, a */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Directionality\", function() { return Directionality; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DIR_DOCUMENT\", function() { return DIR_DOCUMENT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dir\", function() { return Dir; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BidiModule\", function() { return BidiModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return DIR_DOCUMENT_FACTORY; });\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/common */ \"./node_modules/@angular/common/fesm2015/common.js\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm2015/core.js\");\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n *\n * This token is defined in a separate file from Directionality as a workaround for\n * https://github.com/angular/angular/issues/22559\n *\n * \\@docs-private\n * @type {?}\n */\nconst DIR_DOCUMENT = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"InjectionToken\"]('cdk-dir-doc', {\n    providedIn: 'root',\n    factory: DIR_DOCUMENT_FACTORY,\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction DIR_DOCUMENT_FACTORY() {\n    return Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"inject\"])(_angular_common__WEBPACK_IMPORTED_MODULE_0__[\"DOCUMENT\"]);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nclass Directionality {\n    /**\n     * @param {?=} _document\n     */\n    constructor(_document) {\n        /**\n         * The current 'ltr' or 'rtl' value.\n         */\n        this.value = 'ltr';\n        /**\n         * Stream that emits whenever the 'ltr' / 'rtl' state changes.\n         */\n        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"EventEmitter\"]();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            /** @type {?} */\n            const bodyDir = _document.body ? _document.body.dir : null;\n            /** @type {?} */\n            const htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            /** @type {?} */\n            const value = bodyDir || htmlDir;\n            this.value = (value === 'ltr' || value === 'rtl') ? value : 'ltr';\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.change.complete();\n    }\n}\nDirectionality.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Injectable\"], args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nDirectionality.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Optional\"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Inject\"], args: [DIR_DOCUMENT,] }] }\n];\n/** @nocollapse */ Directionality.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"defineInjectable\"])({ factory: function Directionality_Factory() { return new Directionality(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"inject\"])(DIR_DOCUMENT, 8)); }, token: Directionality, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nclass Dir {\n    constructor() {\n        /**\n         * Normalized direction that accounts for invalid/unsupported values.\n         */\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"EventEmitter\"]();\n    }\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    get dir() { return this._dir; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set dir(value) {\n        /** @type {?} */\n        const old = this._dir;\n        /** @type {?} */\n        const normalizedValue = value ? value.toLowerCase() : value;\n        this._rawDir = value;\n        this._dir = (normalizedValue === 'ltr' || normalizedValue === 'rtl') ? normalizedValue : 'ltr';\n        if (old !== this._dir && this._isInitialized) {\n            this.change.emit(this._dir);\n        }\n    }\n    /**\n     * Current layout direction of the element.\n     * @return {?}\n     */\n    get value() { return this.dir; }\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._isInitialized = true;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.change.complete();\n    }\n}\nDir.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Directive\"], args: [{\n                selector: '[dir]',\n                providers: [{ provide: Directionality, useExisting: Dir }],\n                host: { '[attr.dir]': '_rawDir' },\n                exportAs: 'dir',\n            },] },\n];\nDir.propDecorators = {\n    change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Output\"], args: ['dirChange',] }],\n    dir: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass BidiModule {\n}\nBidiModule.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"NgModule\"], args: [{\n                exports: [Dir],\n                declarations: [Dir],\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\n//# sourceMappingURL=bidi.js.map\n\n\n/***/ }),\n\n/***/ \"./node_modules/@angular/cdk/esm2015/drag-drop.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/@angular/cdk/esm2015/drag-drop.js ***!\n  \\********************************************************/\n/*! exports provided: DragDrop, DragRef, DropListRef, CdkDropList, CDK_DROP_LIST, CDK_DROP_LIST_CONTAINER, moveItemInArray, transferArrayItem, copyArrayItem, DragDropModule, DragDropRegistry, CdkDropListGroup, CDK_DRAG_CONFIG_FACTORY, CDK_DRAG_CONFIG, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder, b */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DragDrop\", function() { return DragDrop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DragRef\", function() { return DragRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DropListRef\", function() { return DropListRef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CdkDropList\", function() { return CdkDropList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CDK_DROP_LIST\", function() { return CDK_DROP_LIST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CDK_DROP_LIST_CONTAINER\", function() { return CDK_DROP_LIST_CONTAINER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"moveItemInArray\", function() { return moveItemInArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transferArrayItem\", function() { return transferArrayItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copyArrayItem\", function() { return copyArrayItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DragDropModule\", function() { return DragDropModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DragDropRegistry\", function() { return DragDropRegistry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CdkDropListGroup\", function() { return CdkDropListGroup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CDK_DRAG_CONFIG_FACTORY\", function() { return CDK_DRAG_CONFIG_FACTORY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CDK_DRAG_CONFIG\", function() { return CDK_DRAG_CONFIG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CdkDrag\", function() { return CdkDrag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CdkDragHandle\", function() { return CdkDragHandle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CdkDragPreview\", function() { return CdkDragPreview; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CdkDragPlaceholder\", function() { return CdkDragPlaceholder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return CDK_DRAG_PARENT; });\n/* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/platform */ \"./node_modules/@angular/cdk/esm2015/platform.js\");\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/coercion */ \"./node_modules/@angular/cdk/esm2015/coercion.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm2015/index.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm2015/operators/index.js\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm2015/core.js\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ \"./node_modules/@angular/common/fesm2015/common.js\");\n/* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/scrolling */ \"./node_modules/@angular/cdk/esm2015/scrolling.js\");\n/* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/bidi */ \"./node_modules/@angular/cdk/esm2015/bidi.js\");\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Shallow-extends a stylesheet object with another stylesheet object.\n * \\@docs-private\n * @param {?} dest\n * @param {?} source\n * @return {?}\n */\nfunction extendStyles(dest, source) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            dest[key] = (/** @type {?} */ (source[key]));\n        }\n    }\n    return dest;\n}\n/**\n * Toggles whether the native drag interactions should be enabled for an element.\n * \\@docs-private\n * @param {?} element Element on which to toggle the drag interactions.\n * @param {?} enable Whether the drag interactions should be enabled.\n * @return {?}\n */\nfunction toggleNativeDragInteractions(element, enable) {\n    /** @type {?} */\n    const userSelect = enable ? '' : 'none';\n    extendStyles(element.style, {\n        touchAction: enable ? '' : 'none',\n        webkitUserDrag: enable ? '' : 'none',\n        webkitTapHighlightColor: enable ? '' : 'transparent',\n        userSelect: userSelect,\n        msUserSelect: userSelect,\n        webkitUserSelect: userSelect,\n        MozUserSelect: userSelect\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Parses a CSS time value to milliseconds.\n * @param {?} value\n * @return {?}\n */\nfunction parseCssTimeUnitsToMs(value) {\n    // Some browsers will return it in seconds, whereas others will return milliseconds.\n    /** @type {?} */\n    const multiplier = value.toLowerCase().indexOf('ms') > -1 ? 1 : 1000;\n    return parseFloat(value) * multiplier;\n}\n/**\n * Gets the transform transition duration, including the delay, of an element in milliseconds.\n * @param {?} element\n * @return {?}\n */\nfunction getTransformTransitionDurationInMs(element) {\n    /** @type {?} */\n    const computedStyle = getComputedStyle(element);\n    /** @type {?} */\n    const transitionedProperties = parseCssPropertyValue(computedStyle, 'transition-property');\n    /** @type {?} */\n    const property = transitionedProperties.find((/**\n     * @param {?} prop\n     * @return {?}\n     */\n    prop => prop === 'transform' || prop === 'all'));\n    // If there's no transition for `all` or `transform`, we shouldn't do anything.\n    if (!property) {\n        return 0;\n    }\n    // Get the index of the property that we're interested in and match\n    // it up to the same index in `transition-delay` and `transition-duration`.\n    /** @type {?} */\n    const propertyIndex = transitionedProperties.indexOf(property);\n    /** @type {?} */\n    const rawDurations = parseCssPropertyValue(computedStyle, 'transition-duration');\n    /** @type {?} */\n    const rawDelays = parseCssPropertyValue(computedStyle, 'transition-delay');\n    return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) +\n        parseCssTimeUnitsToMs(rawDelays[propertyIndex]);\n}\n/**\n * Parses out multiple values from a computed style into an array.\n * @param {?} computedStyle\n * @param {?} name\n * @return {?}\n */\nfunction parseCssPropertyValue(computedStyle, name) {\n    /** @type {?} */\n    const value = computedStyle.getPropertyValue(name);\n    return value.split(',').map((/**\n     * @param {?} part\n     * @return {?}\n     */\n    part => part.trim()));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Options that can be used to bind a passive event listener.\n * @type {?}\n */\nconst passiveEventListenerOptions = Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__[\"normalizePassiveListenerOptions\"])({ passive: true });\n/**\n * Options that can be used to bind an active event listener.\n * @type {?}\n */\nconst activeEventListenerOptions = Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__[\"normalizePassiveListenerOptions\"])({ passive: false });\n/**\n * Time in milliseconds for which to ignore mouse events, after\n * receiving a touch event. Used to avoid doing double work for\n * touch devices where the browser fires fake mouse events, in\n * addition to touch events.\n * @type {?}\n */\nconst MOUSE_EVENT_IGNORE_TIME = 800;\n/**\n * Reference to a draggable item. Used to manipulate or dispose of the item.\n * \\@docs-private\n * @template T\n */\nclass DragRef {\n    /**\n     * @param {?} element\n     * @param {?} _config\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewportRuler\n     * @param {?} _dragDropRegistry\n     */\n    constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._config = _config;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n        /**\n         * CSS `transform` applied to the element when it isn't being dragged. We need a\n         * passive transform in order for the dragged element to retain its new position\n         * after the user has stopped dragging and because we need to know the relative\n         * position in case they start dragging again. This corresponds to `element.style.transform`.\n         */\n        this._passiveTransform = { x: 0, y: 0 };\n        /**\n         * CSS `transform` that is applied to the element while it's being dragged.\n         */\n        this._activeTransform = { x: 0, y: 0 };\n        /**\n         * Emits when the item is being moved.\n         */\n        this._moveEvents = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Subscription to pointer movement events.\n         */\n        this._pointerMoveSubscription = rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subscription\"].EMPTY;\n        /**\n         * Subscription to the event that is dispatched when the user lifts their pointer.\n         */\n        this._pointerUpSubscription = rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subscription\"].EMPTY;\n        /**\n         * Subscription to the viewport being scrolled.\n         */\n        this._scrollSubscription = rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subscription\"].EMPTY;\n        /**\n         * Subscription to the viewport being resized.\n         */\n        this._resizeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subscription\"].EMPTY;\n        /**\n         * Cached reference to the boundary element.\n         */\n        this._boundaryElement = null;\n        /**\n         * Whether the native dragging interactions have been enabled on the root element.\n         */\n        this._nativeInteractionsEnabled = true;\n        /**\n         * Elements that can be used to drag the draggable item.\n         */\n        this._handles = [];\n        /**\n         * Registered handles that are currently disabled.\n         */\n        this._disabledHandles = new Set();\n        /**\n         * Layout direction of the item.\n         */\n        this._direction = 'ltr';\n        /**\n         * Amount of milliseconds to wait after the user has put their\n         * pointer down before starting to drag the element.\n         */\n        this.dragStartDelay = 0;\n        this._disabled = false;\n        /**\n         * Emits as the drag sequence is being prepared.\n         */\n        this.beforeStarted = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Emits when the user starts dragging the item.\n         */\n        this.started = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Emits when the user has released a drag item, before any animations have started.\n         */\n        this.released = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Emits when the user stops dragging an item in the container.\n         */\n        this.ended = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Emits when the user has moved the item into a new container.\n         */\n        this.entered = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Emits when the user removes the item its container by dragging it into another container.\n         */\n        this.exited = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Emits when the user drops the item inside a container.\n         */\n        this.dropped = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = this._moveEvents.asObservable();\n        /**\n         * Handler for the `mousedown`/`touchstart` events.\n         */\n        this._pointerDown = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            this.beforeStarted.next();\n            // Delegate the event based on whether it started from a handle or the element itself.\n            if (this._handles.length) {\n                /** @type {?} */\n                const targetHandle = this._handles.find((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => {\n                    /** @type {?} */\n                    const target = event.target;\n                    return !!target && (target === handle || handle.contains((/** @type {?} */ (target))));\n                }));\n                if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {\n                    this._initializeDragSequence(targetHandle, event);\n                }\n            }\n            else if (!this.disabled) {\n                this._initializeDragSequence(this._rootElement, event);\n            }\n        });\n        /**\n         * Handler that is invoked when the user moves their pointer after they've initiated a drag.\n         */\n        this._pointerMove = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            if (!this._hasStartedDragging) {\n                /** @type {?} */\n                const pointerPosition = this._getPointerPositionOnPage(event);\n                /** @type {?} */\n                const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);\n                /** @type {?} */\n                const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);\n                /** @type {?} */\n                const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;\n                // Only start dragging after the user has moved more than the minimum distance in either\n                // direction. Note that this is preferrable over doing something like `skip(minimumDistance)`\n                // in the `pointerMove` subscription, because we're not guaranteed to have one move event\n                // per pixel of movement (e.g. if the user moves their pointer quickly).\n                if (isOverThreshold) {\n                    /** @type {?} */\n                    const isDelayElapsed = Date.now() >= this._dragStartTime + (this.dragStartDelay || 0);\n                    if (!isDelayElapsed) {\n                        this._endDragSequence(event);\n                        return;\n                    }\n                    // Prevent other drag sequences from starting while something in the container is still\n                    // being dragged. This can happen while we're waiting for the drop animation to finish\n                    // and can cause errors, because some elements might still be moving around.\n                    if (!this._dropContainer || !this._dropContainer.isDragging()) {\n                        this._hasStartedDragging = true;\n                        this._ngZone.run((/**\n                         * @return {?}\n                         */\n                        () => this._startDragSequence(event)));\n                    }\n                }\n                return;\n            }\n            // We only need the preview dimensions if we have a boundary element.\n            if (this._boundaryElement) {\n                // Cache the preview element rect if we haven't cached it already or if\n                // we cached it too early before the element dimensions were computed.\n                if (!this._previewRect || (!this._previewRect.width && !this._previewRect.height)) {\n                    this._previewRect = (this._preview || this._rootElement).getBoundingClientRect();\n                }\n            }\n            /** @type {?} */\n            const constrainedPointerPosition = this._getConstrainedPointerPosition(event);\n            this._hasMoved = true;\n            event.preventDefault();\n            this._updatePointerDirectionDelta(constrainedPointerPosition);\n            if (this._dropContainer) {\n                this._updateActiveDropContainer(constrainedPointerPosition);\n            }\n            else {\n                /** @type {?} */\n                const activeTransform = this._activeTransform;\n                activeTransform.x =\n                    constrainedPointerPosition.x - this._pickupPositionOnPage.x + this._passiveTransform.x;\n                activeTransform.y =\n                    constrainedPointerPosition.y - this._pickupPositionOnPage.y + this._passiveTransform.y;\n                this._applyRootElementTransform(activeTransform.x, activeTransform.y);\n                // Apply transform as attribute if dragging and svg element to work for IE\n                if (typeof SVGElement !== 'undefined' && this._rootElement instanceof SVGElement) {\n                    /** @type {?} */\n                    const appliedTransform = `translate(${activeTransform.x} ${activeTransform.y})`;\n                    this._rootElement.setAttribute('transform', appliedTransform);\n                }\n            }\n            // Since this event gets fired for every pixel while dragging, we only\n            // want to fire it if the consumer opted into it. Also we have to\n            // re-enter the zone because we run all of the events on the outside.\n            if (this._moveEvents.observers.length) {\n                this._ngZone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this._moveEvents.next({\n                        source: this,\n                        pointerPosition: constrainedPointerPosition,\n                        event,\n                        distance: this._getDragDistance(constrainedPointerPosition),\n                        delta: this._pointerDirectionDelta\n                    });\n                }));\n            }\n        });\n        /**\n         * Handler that is invoked when the user lifts their pointer up, after initiating a drag.\n         */\n        this._pointerUp = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            this._endDragSequence(event);\n        });\n        this.withRootElement(element);\n        _dragDropRegistry.registerDragItem(this);\n    }\n    /**\n     * Whether starting to drag this element is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        /** @type {?} */\n        const newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceBooleanProperty\"])(value);\n        if (newValue !== this._disabled) {\n            this._disabled = newValue;\n            this._toggleNativeDragInteractions();\n        }\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    getPlaceholderElement() {\n        return this._placeholder;\n    }\n    /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    getRootElement() {\n        return this._rootElement;\n    }\n    /**\n     * Registers the handles that can be used to drag the element.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} handles\n     * @return {THIS}\n     */\n    withHandles(handles) {\n        (/** @type {?} */ (this))._handles = handles.map((/**\n         * @param {?} handle\n         * @return {?}\n         */\n        handle => Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceElement\"])(handle)));\n        (/** @type {?} */ (this))._handles.forEach((/**\n         * @param {?} handle\n         * @return {?}\n         */\n        handle => toggleNativeDragInteractions(handle, false)));\n        (/** @type {?} */ (this))._toggleNativeDragInteractions();\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Registers the template that should be used for the drag preview.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the preview.\n     * @return {THIS}\n     */\n    withPreviewTemplate(template) {\n        (/** @type {?} */ (this))._previewTemplate = template;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Registers the template that should be used for the drag placeholder.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the placeholder.\n     * @return {THIS}\n     */\n    withPlaceholderTemplate(template) {\n        (/** @type {?} */ (this))._placeholderTemplate = template;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets an alternate drag root element. The root element is the element that will be moved as\n     * the user is dragging. Passing an alternate root element is useful when trying to enable\n     * dragging on an element that you might not have access to.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} rootElement\n     * @return {THIS}\n     */\n    withRootElement(rootElement) {\n        /** @type {?} */\n        const element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceElement\"])(rootElement);\n        if (element !== (/** @type {?} */ (this))._rootElement) {\n            if ((/** @type {?} */ (this))._rootElement) {\n                (/** @type {?} */ (this))._removeRootElementListeners((/** @type {?} */ (this))._rootElement);\n            }\n            element.addEventListener('mousedown', (/** @type {?} */ (this))._pointerDown, activeEventListenerOptions);\n            element.addEventListener('touchstart', (/** @type {?} */ (this))._pointerDown, passiveEventListenerOptions);\n            (/** @type {?} */ (this))._initialTransform = undefined;\n            (/** @type {?} */ (this))._rootElement = element;\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Element to which the draggable's position will be constrained.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} boundaryElement\n     * @return {THIS}\n     */\n    withBoundaryElement(boundaryElement) {\n        (/** @type {?} */ (this))._boundaryElement = boundaryElement ? Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceElement\"])(boundaryElement) : null;\n        (/** @type {?} */ (this))._resizeSubscription.unsubscribe();\n        if (boundaryElement) {\n            (/** @type {?} */ (this))._resizeSubscription = (/** @type {?} */ (this))._viewportRuler\n                .change(10)\n                .subscribe((/**\n             * @return {?}\n             */\n            () => (/** @type {?} */ (this))._containInsideBoundaryOnResize()));\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Removes the dragging functionality from the DOM element.\n     * @return {?}\n     */\n    dispose() {\n        this._removeRootElementListeners(this._rootElement);\n        // Do this check before removing from the registry since it'll\n        // stop being considered as dragged once it is removed.\n        if (this.isDragging()) {\n            // Since we move out the element to the end of the body while it's being\n            // dragged, we have to make sure that it's removed if it gets destroyed.\n            removeElement(this._rootElement);\n        }\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._dragDropRegistry.removeDragItem(this);\n        this._removeSubscriptions();\n        this.beforeStarted.complete();\n        this.started.complete();\n        this.released.complete();\n        this.ended.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this._moveEvents.complete();\n        this._handles = [];\n        this._disabledHandles.clear();\n        this._dropContainer = undefined;\n        this._boundaryElement = this._rootElement = this._placeholderTemplate =\n            this._previewTemplate = this._nextSibling = (/** @type {?} */ (null));\n    }\n    /**\n     * Checks whether the element is currently being dragged.\n     * @return {?}\n     */\n    isDragging() {\n        return this._hasStartedDragging && this._dragDropRegistry.isDragging(this);\n    }\n    /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    reset() {\n        this._rootElement.style.transform = this._initialTransform || '';\n        this._activeTransform = { x: 0, y: 0 };\n        this._passiveTransform = { x: 0, y: 0 };\n    }\n    /**\n     * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.\n     * @param {?} handle Handle element that should be disabled.\n     * @return {?}\n     */\n    disableHandle(handle) {\n        if (this._handles.indexOf(handle) > -1) {\n            this._disabledHandles.add(handle);\n        }\n    }\n    /**\n     * Enables a handle, if it has been disabled.\n     * @param {?} handle Handle element to be enabled.\n     * @return {?}\n     */\n    enableHandle(handle) {\n        this._disabledHandles.delete(handle);\n    }\n    /**\n     * Sets the layout direction of the draggable item.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    withDirection(direction) {\n        (/** @type {?} */ (this))._direction = direction;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the container that the item is part of.\n     * @param {?} container\n     * @return {?}\n     */\n    _withDropContainer(container) {\n        this._dropContainer = container;\n    }\n    /**\n     * Gets the current position in pixels the draggable outside of a drop container.\n     * @return {?}\n     */\n    getFreeDragPosition() {\n        /** @type {?} */\n        const position = this.isDragging() ? this._activeTransform : this._passiveTransform;\n        return { x: position.x, y: position.y };\n    }\n    /**\n     * Sets the current position in pixels the draggable outside of a drop container.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} value New position to be set.\n     * @return {THIS}\n     */\n    setFreeDragPosition(value) {\n        (/** @type {?} */ (this))._activeTransform = { x: 0, y: 0 };\n        (/** @type {?} */ (this))._passiveTransform.x = value.x;\n        (/** @type {?} */ (this))._passiveTransform.y = value.y;\n        if (!(/** @type {?} */ (this))._dropContainer) {\n            (/** @type {?} */ (this))._applyRootElementTransform(value.x, value.y);\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Updates the item's sort order based on the last-known pointer position.\n     * @return {?}\n     */\n    _sortFromLastPointerPosition() {\n        /** @type {?} */\n        const position = this._pointerPositionAtLastDirectionChange;\n        if (position && this._dropContainer) {\n            this._updateActiveDropContainer(position);\n        }\n    }\n    /**\n     * Unsubscribes from the global subscriptions.\n     * @private\n     * @return {?}\n     */\n    _removeSubscriptions() {\n        this._pointerMoveSubscription.unsubscribe();\n        this._pointerUpSubscription.unsubscribe();\n        this._scrollSubscription.unsubscribe();\n    }\n    /**\n     * Destroys the preview element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    _destroyPreview() {\n        if (this._preview) {\n            removeElement(this._preview);\n        }\n        if (this._previewRef) {\n            this._previewRef.destroy();\n        }\n        this._preview = this._previewRef = (/** @type {?} */ (null));\n    }\n    /**\n     * Destroys the placeholder element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    _destroyPlaceholder() {\n        if (this._placeholder) {\n            removeElement(this._placeholder);\n        }\n        if (this._placeholderRef) {\n            this._placeholderRef.destroy();\n        }\n        this._placeholder = this._placeholderRef = (/** @type {?} */ (null));\n    }\n    /**\n     * Clears subscriptions and stops the dragging sequence.\n     * @private\n     * @param {?} event Browser event object that ended the sequence.\n     * @return {?}\n     */\n    _endDragSequence(event) {\n        // Note that here we use `isDragging` from the service, rather than from `this`.\n        // The difference is that the one from the service reflects whether a dragging sequence\n        // has been initiated, whereas the one on `this` includes whether the user has passed\n        // the minimum dragging threshold.\n        if (!this._dragDropRegistry.isDragging(this)) {\n            return;\n        }\n        this._removeSubscriptions();\n        this._dragDropRegistry.stopDragging(this);\n        this._toggleNativeDragInteractions();\n        if (this._handles) {\n            this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;\n        }\n        if (!this._hasStartedDragging) {\n            return;\n        }\n        this.released.next({ source: this });\n        if (this._dropContainer) {\n            // Stop scrolling immediately, instead of waiting for the animation to finish.\n            this._dropContainer._stopScrolling();\n            this._animatePreviewToPlaceholder().then((/**\n             * @return {?}\n             */\n            () => {\n                this._cleanupDragArtifacts(event);\n                this._cleanupCachedDimensions();\n                this._dragDropRegistry.stopDragging(this);\n            }));\n        }\n        else {\n            // Convert the active transform into a passive one. This means that next time\n            // the user starts dragging the item, its position will be calculated relatively\n            // to the new passive transform.\n            this._passiveTransform.x = this._activeTransform.x;\n            this._passiveTransform.y = this._activeTransform.y;\n            this._ngZone.run((/**\n             * @return {?}\n             */\n            () => {\n                this.ended.next({\n                    source: this,\n                    distance: this._getDragDistance(this._getPointerPositionOnPage(event))\n                });\n            }));\n            this._cleanupCachedDimensions();\n            this._dragDropRegistry.stopDragging(this);\n        }\n    }\n    /**\n     * Starts the dragging sequence.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _startDragSequence(event) {\n        // Emit the event on the item before the one on the container.\n        this.started.next({ source: this });\n        if (isTouchEvent(event)) {\n            this._lastTouchEventTime = Date.now();\n        }\n        this._toggleNativeDragInteractions();\n        if (this._dropContainer) {\n            /** @type {?} */\n            const element = this._rootElement;\n            // Grab the `nextSibling` before the preview and placeholder\n            // have been created so we don't get the preview by accident.\n            this._nextSibling = element.nextSibling;\n            /** @type {?} */\n            const preview = this._preview = this._createPreviewElement();\n            /** @type {?} */\n            const placeholder = this._placeholder = this._createPlaceholderElement();\n            // We move the element out at the end of the body and we make it hidden, because keeping it in\n            // place will throw off the consumer's `:last-child` selectors. We can't remove the element\n            // from the DOM completely, because iOS will stop firing all subsequent events in the chain.\n            element.style.display = 'none';\n            this._document.body.appendChild((/** @type {?} */ (element.parentNode)).replaceChild(placeholder, element));\n            getPreviewInsertionPoint(this._document).appendChild(preview);\n            this._dropContainer.start();\n        }\n    }\n    /**\n     * Sets up the different variables and subscriptions\n     * that will be necessary for the dragging sequence.\n     * @private\n     * @param {?} referenceElement Element that started the drag sequence.\n     * @param {?} event Browser event object that started the sequence.\n     * @return {?}\n     */\n    _initializeDragSequence(referenceElement, event) {\n        // Always stop propagation for the event that initializes\n        // the dragging sequence, in order to prevent it from potentially\n        // starting another sequence for a draggable parent somewhere up the DOM tree.\n        event.stopPropagation();\n        /** @type {?} */\n        const isDragging = this.isDragging();\n        /** @type {?} */\n        const isTouchSequence = isTouchEvent(event);\n        /** @type {?} */\n        const isAuxiliaryMouseButton = !isTouchSequence && ((/** @type {?} */ (event))).button !== 0;\n        /** @type {?} */\n        const rootElement = this._rootElement;\n        /** @type {?} */\n        const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime &&\n            this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();\n        // If the event started from an element with the native HTML drag&drop, it'll interfere\n        // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n        // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n        // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n        // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n        // events from firing on touch devices.\n        if (event.target && ((/** @type {?} */ (event.target))).draggable && event.type === 'mousedown') {\n            event.preventDefault();\n        }\n        // Abort if the user is already dragging or is using a mouse button other than the primary one.\n        if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent) {\n            return;\n        }\n        // If we've got handles, we need to disable the tap highlight on the entire root element,\n        // otherwise iOS will still add it, even though all the drag interactions on the handle\n        // are disabled.\n        if (this._handles.length) {\n            this._rootElementTapHighlight = rootElement.style.webkitTapHighlightColor;\n            rootElement.style.webkitTapHighlightColor = 'transparent';\n        }\n        this._hasStartedDragging = this._hasMoved = false;\n        this._initialContainer = (/** @type {?} */ (this._dropContainer));\n        // Avoid multiple subscriptions and memory leaks when multi touch\n        // (isDragging check above isn't enough because of possible temporal and/or dimensional delays)\n        this._removeSubscriptions();\n        this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);\n        this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);\n        this._scrollSubscription = this._dragDropRegistry.scroll.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[\"startWith\"])(null)).subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._scrollPosition = this._viewportRuler.getViewportScrollPosition();\n        }));\n        if (this._boundaryElement) {\n            this._boundaryRect = this._boundaryElement.getBoundingClientRect();\n        }\n        // If we have a custom preview template, the element won't be visible anyway so we avoid the\n        // extra `getBoundingClientRect` calls and just move the preview next to the cursor.\n        this._pickupPositionInElement = this._previewTemplate && this._previewTemplate.template ?\n            { x: 0, y: 0 } :\n            this._getPointerPositionInElement(referenceElement, event);\n        /** @type {?} */\n        const pointerPosition = this._pickupPositionOnPage = this._getPointerPositionOnPage(event);\n        this._pointerDirectionDelta = { x: 0, y: 0 };\n        this._pointerPositionAtLastDirectionChange = { x: pointerPosition.x, y: pointerPosition.y };\n        this._dragStartTime = Date.now();\n        this._dragDropRegistry.startDragging(this, event);\n    }\n    /**\n     * Cleans up the DOM artifacts that were added to facilitate the element being dragged.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _cleanupDragArtifacts(event) {\n        // Restore the element's visibility and insert it at its old position in the DOM.\n        // It's important that we maintain the position, because moving the element around in the DOM\n        // can throw off `NgFor` which does smart diffing and re-creates elements only when necessary,\n        // while moving the existing elements in all other cases.\n        this._rootElement.style.display = '';\n        if (this._nextSibling) {\n            (/** @type {?} */ (this._nextSibling.parentNode)).insertBefore(this._rootElement, this._nextSibling);\n        }\n        else {\n            Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceElement\"])(this._initialContainer.element).appendChild(this._rootElement);\n        }\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._boundaryRect = this._previewRect = undefined;\n        // Re-enter the NgZone since we bound `document` events on the outside.\n        this._ngZone.run((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const container = (/** @type {?} */ (this._dropContainer));\n            /** @type {?} */\n            const currentIndex = container.getItemIndex(this);\n            /** @type {?} */\n            const pointerPosition = this._getPointerPositionOnPage(event);\n            /** @type {?} */\n            const distance = this._getDragDistance(this._getPointerPositionOnPage(event));\n            /** @type {?} */\n            const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);\n            this.ended.next({ source: this, distance });\n            this.dropped.next({\n                item: this,\n                currentIndex,\n                previousIndex: this._initialContainer.getItemIndex(this),\n                container: container,\n                previousContainer: this._initialContainer,\n                isPointerOverContainer,\n                distance\n            });\n            container.drop(this, currentIndex, this._initialContainer, isPointerOverContainer, distance);\n            this._dropContainer = this._initialContainer;\n        }));\n    }\n    /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     * @private\n     * @param {?} __0\n     * @return {?}\n     */\n    _updateActiveDropContainer({ x, y }) {\n        // Drop container that draggable has been moved into.\n        /** @type {?} */\n        let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);\n        // If we couldn't find a new container to move the item into, and the item has left its\n        // initial container, check whether the it's over the initial container. This handles the\n        // case where two containers are connected one way and the user tries to undo dragging an\n        // item into a new container.\n        if (!newContainer && this._dropContainer !== this._initialContainer &&\n            this._initialContainer._isOverContainer(x, y)) {\n            newContainer = this._initialContainer;\n        }\n        if (newContainer && newContainer !== this._dropContainer) {\n            this._ngZone.run((/**\n             * @return {?}\n             */\n            () => {\n                // Notify the old container that the item has left.\n                this.exited.next({ item: this, container: (/** @type {?} */ (this._dropContainer)) });\n                (/** @type {?} */ (this._dropContainer)).exit(this);\n                // Notify the new container that the item has entered.\n                this._dropContainer = (/** @type {?} */ (newContainer));\n                this._dropContainer.enter(this, x, y);\n                this.entered.next({\n                    item: this,\n                    container: (/** @type {?} */ (newContainer)),\n                    currentIndex: (/** @type {?} */ (newContainer)).getItemIndex(this)\n                });\n            }));\n        }\n        (/** @type {?} */ (this._dropContainer))._startScrollingIfNecessary(x, y);\n        (/** @type {?} */ (this._dropContainer))._sortItem(this, x, y, this._pointerDirectionDelta);\n        this._preview.style.transform =\n            getTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);\n    }\n    /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     * @private\n     * @return {?}\n     */\n    _createPreviewElement() {\n        /** @type {?} */\n        const previewConfig = this._previewTemplate;\n        /** @type {?} */\n        const previewTemplate = previewConfig ? previewConfig.template : null;\n        /** @type {?} */\n        let preview;\n        if (previewTemplate) {\n            /** @type {?} */\n            const viewRef = (/** @type {?} */ (previewConfig)).viewContainer.createEmbeddedView(previewTemplate, (/** @type {?} */ (previewConfig)).context);\n            preview = getRootNode(viewRef, this._document);\n            this._previewRef = viewRef;\n            preview.style.transform =\n                getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);\n        }\n        else {\n            /** @type {?} */\n            const element = this._rootElement;\n            /** @type {?} */\n            const elementRect = element.getBoundingClientRect();\n            preview = deepCloneNode(element);\n            preview.style.width = `${elementRect.width}px`;\n            preview.style.height = `${elementRect.height}px`;\n            preview.style.transform = getTransform(elementRect.left, elementRect.top);\n        }\n        extendStyles(preview.style, {\n            // It's important that we disable the pointer events on the preview, because\n            // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.\n            pointerEvents: 'none',\n            // We have to reset the margin, because can throw off positioning relative to the viewport.\n            margin: '0',\n            position: 'fixed',\n            top: '0',\n            left: '0',\n            zIndex: '1000'\n        });\n        toggleNativeDragInteractions(preview, false);\n        preview.classList.add('cdk-drag-preview');\n        preview.setAttribute('dir', this._direction);\n        return preview;\n    }\n    /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @private\n     * @return {?} Promise that resolves when the animation completes.\n     */\n    _animatePreviewToPlaceholder() {\n        // If the user hasn't moved yet, the transitionend event won't fire.\n        if (!this._hasMoved) {\n            return Promise.resolve();\n        }\n        /** @type {?} */\n        const placeholderRect = this._placeholder.getBoundingClientRect();\n        // Apply the class that adds a transition to the preview.\n        this._preview.classList.add('cdk-drag-animating');\n        // Move the preview to the placeholder position.\n        this._preview.style.transform = getTransform(placeholderRect.left, placeholderRect.top);\n        // If the element doesn't have a `transition`, the `transitionend` event won't fire. Since\n        // we need to trigger a style recalculation in order for the `cdk-drag-animating` class to\n        // apply its style, we take advantage of the available info to figure out whether we need to\n        // bind the event in the first place.\n        /** @type {?} */\n        const duration = getTransformTransitionDurationInMs(this._preview);\n        if (duration === 0) {\n            return Promise.resolve();\n        }\n        return this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            return new Promise((/**\n             * @param {?} resolve\n             * @return {?}\n             */\n            resolve => {\n                /** @type {?} */\n                const handler = (/** @type {?} */ (((/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                (event) => {\n                    if (!event || (event.target === this._preview && event.propertyName === 'transform')) {\n                        this._preview.removeEventListener('transitionend', handler);\n                        resolve();\n                        clearTimeout(timeout);\n                    }\n                }))));\n                // If a transition is short enough, the browser might not fire the `transitionend` event.\n                // Since we know how long it's supposed to take, add a timeout with a 50% buffer that'll\n                // fire if the transition hasn't completed when it was supposed to.\n                /** @type {?} */\n                const timeout = setTimeout((/** @type {?} */ (handler)), duration * 1.5);\n                this._preview.addEventListener('transitionend', handler);\n            }));\n        }));\n    }\n    /**\n     * Creates an element that will be shown instead of the current element while dragging.\n     * @private\n     * @return {?}\n     */\n    _createPlaceholderElement() {\n        /** @type {?} */\n        const placeholderConfig = this._placeholderTemplate;\n        /** @type {?} */\n        const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;\n        /** @type {?} */\n        let placeholder;\n        if (placeholderTemplate) {\n            this._placeholderRef = (/** @type {?} */ (placeholderConfig)).viewContainer.createEmbeddedView(placeholderTemplate, (/** @type {?} */ (placeholderConfig)).context);\n            placeholder = getRootNode(this._placeholderRef, this._document);\n        }\n        else {\n            placeholder = deepCloneNode(this._rootElement);\n        }\n        placeholder.classList.add('cdk-drag-placeholder');\n        return placeholder;\n    }\n    /**\n     * Figures out the coordinates at which an element was picked up.\n     * @private\n     * @param {?} referenceElement Element that initiated the dragging.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    _getPointerPositionInElement(referenceElement, event) {\n        /** @type {?} */\n        const elementRect = this._rootElement.getBoundingClientRect();\n        /** @type {?} */\n        const handleElement = referenceElement === this._rootElement ? null : referenceElement;\n        /** @type {?} */\n        const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;\n        /** @type {?} */\n        const point = isTouchEvent(event) ? event.targetTouches[0] : event;\n        /** @type {?} */\n        const x = point.pageX - referenceRect.left - this._scrollPosition.left;\n        /** @type {?} */\n        const y = point.pageY - referenceRect.top - this._scrollPosition.top;\n        return {\n            x: referenceRect.left - elementRect.left + x,\n            y: referenceRect.top - elementRect.top + y\n        };\n    }\n    /**\n     * Determines the point of the page that was touched by the user.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _getPointerPositionOnPage(event) {\n        // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\n        /** @type {?} */\n        const point = isTouchEvent(event) ? (event.touches[0] || event.changedTouches[0]) : event;\n        return {\n            x: point.pageX - this._scrollPosition.left,\n            y: point.pageY - this._scrollPosition.top\n        };\n    }\n    /**\n     * Gets the pointer position on the page, accounting for any position constraints.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _getConstrainedPointerPosition(event) {\n        /** @type {?} */\n        const point = this._getPointerPositionOnPage(event);\n        /** @type {?} */\n        const constrainedPoint = this.constrainPosition ? this.constrainPosition(point, this) : point;\n        /** @type {?} */\n        const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;\n        if (this.lockAxis === 'x' || dropContainerLock === 'x') {\n            constrainedPoint.y = this._pickupPositionOnPage.y;\n        }\n        else if (this.lockAxis === 'y' || dropContainerLock === 'y') {\n            constrainedPoint.x = this._pickupPositionOnPage.x;\n        }\n        if (this._boundaryRect) {\n            const { x: pickupX, y: pickupY } = this._pickupPositionInElement;\n            /** @type {?} */\n            const boundaryRect = this._boundaryRect;\n            /** @type {?} */\n            const previewRect = (/** @type {?} */ (this._previewRect));\n            /** @type {?} */\n            const minY = boundaryRect.top + pickupY;\n            /** @type {?} */\n            const maxY = boundaryRect.bottom - (previewRect.height - pickupY);\n            /** @type {?} */\n            const minX = boundaryRect.left + pickupX;\n            /** @type {?} */\n            const maxX = boundaryRect.right - (previewRect.width - pickupX);\n            constrainedPoint.x = clamp(constrainedPoint.x, minX, maxX);\n            constrainedPoint.y = clamp(constrainedPoint.y, minY, maxY);\n        }\n        return constrainedPoint;\n    }\n    /**\n     * Updates the current drag delta, based on the user's current pointer position on the page.\n     * @private\n     * @param {?} pointerPositionOnPage\n     * @return {?}\n     */\n    _updatePointerDirectionDelta(pointerPositionOnPage) {\n        const { x, y } = pointerPositionOnPage;\n        /** @type {?} */\n        const delta = this._pointerDirectionDelta;\n        /** @type {?} */\n        const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;\n        // Amount of pixels the user has dragged since the last time the direction changed.\n        /** @type {?} */\n        const changeX = Math.abs(x - positionSinceLastChange.x);\n        /** @type {?} */\n        const changeY = Math.abs(y - positionSinceLastChange.y);\n        // Because we handle pointer events on a per-pixel basis, we don't want the delta\n        // to change for every pixel, otherwise anything that depends on it can look erratic.\n        // To make the delta more consistent, we track how much the user has moved since the last\n        // delta change and we only update it after it has reached a certain threshold.\n        if (changeX > this._config.pointerDirectionChangeThreshold) {\n            delta.x = x > positionSinceLastChange.x ? 1 : -1;\n            positionSinceLastChange.x = x;\n        }\n        if (changeY > this._config.pointerDirectionChangeThreshold) {\n            delta.y = y > positionSinceLastChange.y ? 1 : -1;\n            positionSinceLastChange.y = y;\n        }\n        return delta;\n    }\n    /**\n     * Toggles the native drag interactions, based on how many handles are registered.\n     * @private\n     * @return {?}\n     */\n    _toggleNativeDragInteractions() {\n        if (!this._rootElement || !this._handles) {\n            return;\n        }\n        /** @type {?} */\n        const shouldEnable = this._handles.length > 0 || !this.isDragging();\n        if (shouldEnable !== this._nativeInteractionsEnabled) {\n            this._nativeInteractionsEnabled = shouldEnable;\n            toggleNativeDragInteractions(this._rootElement, shouldEnable);\n        }\n    }\n    /**\n     * Removes the manually-added event listeners from the root element.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    _removeRootElementListeners(element) {\n        element.removeEventListener('mousedown', this._pointerDown, activeEventListenerOptions);\n        element.removeEventListener('touchstart', this._pointerDown, passiveEventListenerOptions);\n    }\n    /**\n     * Applies a `transform` to the root element, taking into account any existing transforms on it.\n     * @private\n     * @param {?} x New transform value along the X axis.\n     * @param {?} y New transform value along the Y axis.\n     * @return {?}\n     */\n    _applyRootElementTransform(x, y) {\n        /** @type {?} */\n        const transform = getTransform(x, y);\n        // Cache the previous transform amount only after the first drag sequence, because\n        // we don't want our own transforms to stack on top of each other.\n        if (this._initialTransform == null) {\n            this._initialTransform = this._rootElement.style.transform || '';\n        }\n        // Preserve the previous `transform` value, if there was one. Note that we apply our own\n        // transform before the user's, because things like rotation can affect which direction\n        // the element will be translated towards.\n        this._rootElement.style.transform = this._initialTransform ?\n            transform + ' ' + this._initialTransform : transform;\n    }\n    /**\n     * Gets the distance that the user has dragged during the current drag sequence.\n     * @private\n     * @param {?} currentPosition Current position of the user's pointer.\n     * @return {?}\n     */\n    _getDragDistance(currentPosition) {\n        /** @type {?} */\n        const pickupPosition = this._pickupPositionOnPage;\n        if (pickupPosition) {\n            return { x: currentPosition.x - pickupPosition.x, y: currentPosition.y - pickupPosition.y };\n        }\n        return { x: 0, y: 0 };\n    }\n    /**\n     * Cleans up any cached element dimensions that we don't need after dragging has stopped.\n     * @private\n     * @return {?}\n     */\n    _cleanupCachedDimensions() {\n        this._boundaryRect = this._previewRect = undefined;\n    }\n    /**\n     * Checks whether the element is still inside its boundary after the viewport has been resized.\n     * If not, the position is adjusted so that the element fits again.\n     * @private\n     * @return {?}\n     */\n    _containInsideBoundaryOnResize() {\n        let { x, y } = this._passiveTransform;\n        if ((x === 0 && y === 0) || this.isDragging() || !this._boundaryElement) {\n            return;\n        }\n        /** @type {?} */\n        const boundaryRect = this._boundaryElement.getBoundingClientRect();\n        /** @type {?} */\n        const elementRect = this._rootElement.getBoundingClientRect();\n        /** @type {?} */\n        const leftOverflow = boundaryRect.left - elementRect.left;\n        /** @type {?} */\n        const rightOverflow = elementRect.right - boundaryRect.right;\n        /** @type {?} */\n        const topOverflow = boundaryRect.top - elementRect.top;\n        /** @type {?} */\n        const bottomOverflow = elementRect.bottom - boundaryRect.bottom;\n        // If the element has become wider than the boundary, we can't\n        // do much to make it fit so we just anchor it to the left.\n        if (boundaryRect.width > elementRect.width) {\n            if (leftOverflow > 0) {\n                x += leftOverflow;\n            }\n            if (rightOverflow > 0) {\n                x -= rightOverflow;\n            }\n        }\n        else {\n            x = 0;\n        }\n        // If the element has become taller than the boundary, we can't\n        // do much to make it fit so we just anchor it to the top.\n        if (boundaryRect.height > elementRect.height) {\n            if (topOverflow > 0) {\n                y += topOverflow;\n            }\n            if (bottomOverflow > 0) {\n                y -= bottomOverflow;\n            }\n        }\n        else {\n            y = 0;\n        }\n        if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {\n            this.setFreeDragPosition({ y, x });\n        }\n    }\n}\n/**\n * Gets a 3d `transform` that can be applied to an element.\n * @param {?} x Desired position of the element along the X axis.\n * @param {?} y Desired position of the element along the Y axis.\n * @return {?}\n */\nfunction getTransform(x, y) {\n    // Round the transforms since some browsers will\n    // blur the elements for sub-pixel transforms.\n    return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;\n}\n/**\n * Creates a deep clone of an element.\n * @param {?} node\n * @return {?}\n */\nfunction deepCloneNode(node) {\n    /** @type {?} */\n    const clone = (/** @type {?} */ (node.cloneNode(true)));\n    /** @type {?} */\n    const descendantsWithId = clone.querySelectorAll('[id]');\n    /** @type {?} */\n    const descendantCanvases = node.querySelectorAll('canvas');\n    // Remove the `id` to avoid having multiple elements with the same id on the page.\n    clone.removeAttribute('id');\n    for (let i = 0; i < descendantsWithId.length; i++) {\n        descendantsWithId[i].removeAttribute('id');\n    }\n    // `cloneNode` won't transfer the content of `canvas` elements so we have to do it ourselves.\n    // We match up the cloned canvas to their sources using their index in the DOM.\n    if (descendantCanvases.length) {\n        /** @type {?} */\n        const cloneCanvases = clone.querySelectorAll('canvas');\n        for (let i = 0; i < descendantCanvases.length; i++) {\n            /** @type {?} */\n            const correspondingCloneContext = cloneCanvases[i].getContext('2d');\n            if (correspondingCloneContext) {\n                correspondingCloneContext.drawImage(descendantCanvases[i], 0, 0);\n            }\n        }\n    }\n    return clone;\n}\n/**\n * Clamps a value between a minimum and a maximum.\n * @param {?} value\n * @param {?} min\n * @param {?} max\n * @return {?}\n */\nfunction clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * Helper to remove an element from the DOM and to do all the necessary null checks.\n * @param {?} element Element to be removed.\n * @return {?}\n */\nfunction removeElement(element) {\n    if (element && element.parentNode) {\n        element.parentNode.removeChild(element);\n    }\n}\n/**\n * Determines whether an event is a touch event.\n * @param {?} event\n * @return {?}\n */\nfunction isTouchEvent(event) {\n    // This function is called for every pixel that the user has dragged so we need it to be\n    // as fast as possible. Since we only bind mouse events and touch events, we can assume\n    // that if the event's name starts with `t`, it's a touch event.\n    return event.type[0] === 't';\n}\n/**\n * Gets the element into which the drag preview should be inserted.\n * @param {?} documentRef\n * @return {?}\n */\nfunction getPreviewInsertionPoint(documentRef) {\n    // We can't use the body if the user is in fullscreen mode,\n    // because the preview will render under the fullscreen element.\n    // TODO(crisbeto): dedupe this with the `FullscreenOverlayContainer` eventually.\n    return documentRef.fullscreenElement ||\n        documentRef.webkitFullscreenElement ||\n        documentRef.mozFullScreenElement ||\n        documentRef.msFullscreenElement ||\n        documentRef.body;\n}\n/**\n * Gets the root HTML element of an embedded view.\n * If the root is not an HTML element it gets wrapped in one.\n * @param {?} viewRef\n * @param {?} _document\n * @return {?}\n */\nfunction getRootNode(viewRef, _document) {\n    /** @type {?} */\n    const rootNode = viewRef.rootNodes[0];\n    if (rootNode.nodeType !== _document.ELEMENT_NODE) {\n        /** @type {?} */\n        const wrapper = _document.createElement('div');\n        wrapper.appendChild(rootNode);\n        return wrapper;\n    }\n    return (/** @type {?} */ (rootNode));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Moves an item one index in an array to another.\n * @template T\n * @param {?} array Array in which to move the item.\n * @param {?} fromIndex Starting index of the item.\n * @param {?} toIndex Index to which the item should be moved.\n * @return {?}\n */\nfunction moveItemInArray(array, fromIndex, toIndex) {\n    /** @type {?} */\n    const from = clamp$1(fromIndex, array.length - 1);\n    /** @type {?} */\n    const to = clamp$1(toIndex, array.length - 1);\n    if (from === to) {\n        return;\n    }\n    /** @type {?} */\n    const target = array[from];\n    /** @type {?} */\n    const delta = to < from ? -1 : 1;\n    for (let i = from; i !== to; i += delta) {\n        array[i] = array[i + delta];\n    }\n    array[to] = target;\n}\n/**\n * Moves an item from one array to another.\n * @template T\n * @param {?} currentArray Array from which to transfer the item.\n * @param {?} targetArray Array into which to put the item.\n * @param {?} currentIndex Index of the item in its current array.\n * @param {?} targetIndex Index at which to insert the item.\n * @return {?}\n */\nfunction transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    /** @type {?} */\n    const from = clamp$1(currentIndex, currentArray.length - 1);\n    /** @type {?} */\n    const to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);\n    }\n}\n/**\n * Copies an item from one array to another, leaving it in its\n * original position in current array.\n * @template T\n * @param {?} currentArray Array from which to copy the item.\n * @param {?} targetArray Array into which is copy the item.\n * @param {?} currentIndex Index of the item in its current array.\n * @param {?} targetIndex Index at which to insert the item.\n *\n * @return {?}\n */\nfunction copyArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    /** @type {?} */\n    const to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray[currentIndex]);\n    }\n}\n/**\n * Clamps a number between zero and a maximum.\n * @param {?} value\n * @param {?} max\n * @return {?}\n */\nfunction clamp$1(value, max) {\n    return Math.max(0, Math.min(max, value));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Counter used to generate unique ids for drop refs.\n * @type {?}\n */\nlet _uniqueIdCounter = 0;\n/**\n * Proximity, as a ratio to width/height, at which a\n * dragged item will affect the drop container.\n * @type {?}\n */\nconst DROP_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Proximity, as a ratio to width/height at which to start auto-scrolling the drop list or the\n * viewport. The value comes from trying it out manually until it feels right.\n * @type {?}\n */\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Number of pixels to scroll for each frame when auto-scrolling an element.\n * The value comes from trying it out manually until it feels right.\n * @type {?}\n */\nconst AUTO_SCROLL_STEP = 2;\n/**\n * Reference to a drop list. Used to manipulate or dispose of the container.\n * \\@docs-private\n * @template T\n */\nclass DropListRef {\n    /**\n     * @param {?} element\n     * @param {?} _dragDropRegistry\n     * @param {?} _document\n     * @param {?=} _ngZone\n     * @param {?=} _viewportRuler\n     */\n    constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {\n        this._dragDropRegistry = _dragDropRegistry;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        /**\n         * Unique ID for the drop list.\n         * @deprecated No longer being used. To be removed.\n         * \\@breaking-change 8.0.0\n         */\n        this.id = `cdk-drop-list-ref-${_uniqueIdCounter++}`;\n        /**\n         * Whether starting a dragging sequence from this container is disabled.\n         */\n        this.disabled = false;\n        /**\n         * Whether sorting items within the list is disabled.\n         */\n        this.sortingDisabled = false;\n        /**\n         * Whether auto-scrolling the view when the user\n         * moves their pointer close to the edges is disabled.\n         */\n        this.autoScrollDisabled = false;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = (/**\n         * @return {?}\n         */\n        () => true);\n        /**\n         * Emits right before dragging has started.\n         */\n        this.beforeStarted = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Emits when the user drops an item inside the container.\n         */\n        this.dropped = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Emits as the user is swapping items while actively dragging.\n         */\n        this.sorted = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Whether an item in the list is being dragged.\n         */\n        this._isDragging = false;\n        /**\n         * Cache of the dimensions of all the items inside the container.\n         */\n        this._itemPositions = [];\n        /**\n         * Keeps track of the container's scroll position.\n         */\n        this._scrollPosition = { top: 0, left: 0 };\n        /**\n         * Keeps track of the scroll position of the viewport.\n         */\n        this._viewportScrollPosition = { top: 0, left: 0 };\n        /**\n         * Keeps track of the item that was last swapped with the dragged item, as\n         * well as what direction the pointer was moving in when the swap occured.\n         */\n        this._previousSwap = { drag: (/** @type {?} */ (null)), delta: 0 };\n        /**\n         * Drop lists that are connected to the current one.\n         */\n        this._siblings = [];\n        /**\n         * Direction in which the list is oriented.\n         */\n        this._orientation = 'vertical';\n        /**\n         * Connected siblings that currently have a dragged item.\n         */\n        this._activeSiblings = new Set();\n        /**\n         * Layout direction of the drop list.\n         */\n        this._direction = 'ltr';\n        /**\n         * Subscription to the window being scrolled.\n         */\n        this._viewportScrollSubscription = rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subscription\"].EMPTY;\n        /**\n         * Vertical direction in which the list is currently scrolling.\n         */\n        this._verticalScrollDirection = 0 /* NONE */;\n        /**\n         * Horizontal direction in which the list is currently scrolling.\n         */\n        this._horizontalScrollDirection = 0 /* NONE */;\n        /**\n         * Used to signal to the current auto-scroll sequence when to stop.\n         */\n        this._stopScrollTimers = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Handles the container being scrolled. Has to be an arrow function to preserve the context.\n         */\n        this._handleScroll = (/**\n         * @return {?}\n         */\n        () => {\n            if (!this.isDragging()) {\n                return;\n            }\n            /** @type {?} */\n            const element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceElement\"])(this.element);\n            this._updateAfterScroll(this._scrollPosition, element.scrollTop, element.scrollLeft);\n        });\n        /**\n         * Starts the interval that'll auto-scroll the element.\n         */\n        this._startScrollInterval = (/**\n         * @return {?}\n         */\n        () => {\n            this._stopScrolling();\n            Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[\"interval\"])(0, rxjs__WEBPACK_IMPORTED_MODULE_2__[\"animationFrameScheduler\"])\n                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[\"takeUntil\"])(this._stopScrollTimers))\n                .subscribe((/**\n             * @return {?}\n             */\n            () => {\n                /** @type {?} */\n                const node = this._scrollNode;\n                if (this._verticalScrollDirection === 1 /* UP */) {\n                    incrementVerticalScroll(node, -AUTO_SCROLL_STEP);\n                }\n                else if (this._verticalScrollDirection === 2 /* DOWN */) {\n                    incrementVerticalScroll(node, AUTO_SCROLL_STEP);\n                }\n                if (this._horizontalScrollDirection === 1 /* LEFT */) {\n                    incrementHorizontalScroll(node, -AUTO_SCROLL_STEP);\n                }\n                else if (this._horizontalScrollDirection === 2 /* RIGHT */) {\n                    incrementHorizontalScroll(node, AUTO_SCROLL_STEP);\n                }\n            }));\n        });\n        /** @type {?} */\n        const nativeNode = this.element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceElement\"])(element);\n        this._shadowRoot = getShadowRoot(nativeNode) || _document;\n        _dragDropRegistry.registerDropContainer(this);\n    }\n    /**\n     * Removes the drop list functionality from the DOM element.\n     * @return {?}\n     */\n    dispose() {\n        this._stopScrolling();\n        this._stopScrollTimers.complete();\n        this._removeListeners();\n        this.beforeStarted.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this.sorted.complete();\n        this._activeSiblings.clear();\n        this._scrollNode = (/** @type {?} */ (null));\n        this._dragDropRegistry.removeDropContainer(this);\n    }\n    /**\n     * Whether an item from this list is currently being dragged.\n     * @return {?}\n     */\n    isDragging() {\n        return this._isDragging;\n    }\n    /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    start() {\n        /** @type {?} */\n        const element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceElement\"])(this.element);\n        this.beforeStarted.next();\n        this._isDragging = true;\n        this._cacheItems();\n        this._siblings.forEach((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._startReceiving(this)));\n        this._removeListeners();\n        // @breaking-change 9.0.0 Remove check for _ngZone once it's marked as a required param.\n        if (this._ngZone) {\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => element.addEventListener('scroll', this._handleScroll)));\n        }\n        else {\n            element.addEventListener('scroll', this._handleScroll);\n        }\n        // @breaking-change 9.0.0 Remove check for _viewportRuler once it's marked as a required param.\n        if (this._viewportRuler) {\n            this._listenToScrollEvents();\n        }\n    }\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    enter(item, pointerX, pointerY) {\n        this.start();\n        // If sorting is disabled, we want the item to return to its starting\n        // position if the user is returning it to its initial container.\n        /** @type {?} */\n        let newIndex = this.sortingDisabled ? this._draggables.indexOf(item) : -1;\n        if (newIndex === -1) {\n            // We use the coordinates of where the item entered the drop\n            // zone to figure out at which index it should be inserted.\n            newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);\n        }\n        /** @type {?} */\n        const activeDraggables = this._activeDraggables;\n        /** @type {?} */\n        const currentIndex = activeDraggables.indexOf(item);\n        /** @type {?} */\n        const placeholder = item.getPlaceholderElement();\n        /** @type {?} */\n        let newPositionReference = activeDraggables[newIndex];\n        // If the item at the new position is the same as the item that is being dragged,\n        // it means that we're trying to restore the item to its initial position. In this\n        // case we should use the next item from the list as the reference.\n        if (newPositionReference === item) {\n            newPositionReference = activeDraggables[newIndex + 1];\n        }\n        // Since the item may be in the `activeDraggables` already (e.g. if the user dragged it\n        // into another container and back again), we have to ensure that it isn't duplicated.\n        if (currentIndex > -1) {\n            activeDraggables.splice(currentIndex, 1);\n        }\n        // Don't use items that are being dragged as a reference, because\n        // their element has been moved down to the bottom of the body.\n        if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\n            /** @type {?} */\n            const element = newPositionReference.getRootElement();\n            (/** @type {?} */ (element.parentElement)).insertBefore(placeholder, element);\n            activeDraggables.splice(newIndex, 0, item);\n        }\n        else {\n            Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceElement\"])(this.element).appendChild(placeholder);\n            activeDraggables.push(item);\n        }\n        // The transform needs to be cleared so it doesn't throw off the measurements.\n        placeholder.style.transform = '';\n        // Note that the positions were already cached when we called `start` above,\n        // but we need to refresh them since the amount of items has changed.\n        this._cacheItemPositions();\n        this.entered.next({ item, container: this, currentIndex: this.getItemIndex(item) });\n    }\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    exit(item) {\n        this._reset();\n        this.exited.next({ item, container: this });\n    }\n    /**\n     * Drops an item into this container.\n     * \\@breaking-change 9.0.0 `distance` parameter to become required.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @param {?=} distance Distance the user has dragged since the start of the dragging sequence.\n     * @return {?}\n     */\n    drop(item, currentIndex, previousContainer, isPointerOverContainer, distance = { x: 0, y: 0 }) {\n        this._reset();\n        this.dropped.next({\n            item,\n            currentIndex,\n            previousIndex: previousContainer.getItemIndex(item),\n            container: this,\n            previousContainer,\n            isPointerOverContainer,\n            distance\n        });\n    }\n    /**\n     * Sets the draggable items that are a part of this list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} items Items that are a part of this list.\n     * @return {THIS}\n     */\n    withItems(items) {\n        (/** @type {?} */ (this))._draggables = items;\n        items.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        item => item._withDropContainer((/** @type {?} */ (this)))));\n        if ((/** @type {?} */ (this)).isDragging()) {\n            (/** @type {?} */ (this))._cacheItems();\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the layout direction of the drop list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    withDirection(direction) {\n        (/** @type {?} */ (this))._direction = direction;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the containers that are connected to this one. When two or more containers are\n     * connected, the user will be allowed to transfer items between them.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} connectedTo Other containers that the current containers should be connected to.\n     * @return {THIS}\n     */\n    connectedTo(connectedTo) {\n        (/** @type {?} */ (this))._siblings = connectedTo.slice();\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the orientation of the container.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} orientation New orientation for the container.\n     * @return {THIS}\n     */\n    withOrientation(orientation) {\n        (/** @type {?} */ (this))._orientation = orientation;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    getItemIndex(item) {\n        if (!this._isDragging) {\n            return this._draggables.indexOf(item);\n        }\n        // Items are sorted always by top/left in the cache, however they flow differently in RTL.\n        // The rest of the logic still stands no matter what orientation we're in, however\n        // we need to invert the array when determining the index.\n        /** @type {?} */\n        const items = this._orientation === 'horizontal' && this._direction === 'rtl' ?\n            this._itemPositions.slice().reverse() : this._itemPositions;\n        return findIndex(items, (/**\n         * @param {?} currentItem\n         * @return {?}\n         */\n        currentItem => currentItem.drag === item));\n    }\n    /**\n     * Whether the list is able to receive the item that\n     * is currently being dragged inside a connected drop list.\n     * @return {?}\n     */\n    isReceiving() {\n        return this._activeSiblings.size > 0;\n    }\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta Direction in which the pointer is moving along each axis.\n     * @return {?}\n     */\n    _sortItem(item, pointerX, pointerY, pointerDelta) {\n        // Don't sort the item if sorting is disabled or it's out of range.\n        if (this.sortingDisabled || !this._isPointerNearDropContainer(pointerX, pointerY)) {\n            return;\n        }\n        /** @type {?} */\n        const siblings = this._itemPositions;\n        /** @type {?} */\n        const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);\n        if (newIndex === -1 && siblings.length > 0) {\n            return;\n        }\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        const currentIndex = findIndex(siblings, (/**\n         * @param {?} currentItem\n         * @return {?}\n         */\n        currentItem => currentItem.drag === item));\n        /** @type {?} */\n        const siblingAtNewPosition = siblings[newIndex];\n        /** @type {?} */\n        const currentPosition = siblings[currentIndex].clientRect;\n        /** @type {?} */\n        const newPosition = siblingAtNewPosition.clientRect;\n        /** @type {?} */\n        const delta = currentIndex > newIndex ? 1 : -1;\n        this._previousSwap.drag = siblingAtNewPosition.drag;\n        this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;\n        // How many pixels the item's placeholder should be offset.\n        /** @type {?} */\n        const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);\n        // How many pixels all the other items should be offset.\n        /** @type {?} */\n        const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);\n        // Save the previous order of the items before moving the item to its new index.\n        // We use this to check whether an item has been moved as a result of the sorting.\n        /** @type {?} */\n        const oldOrder = siblings.slice();\n        // Shuffle the array in place.\n        moveItemInArray(siblings, currentIndex, newIndex);\n        this.sorted.next({\n            previousIndex: currentIndex,\n            currentIndex: newIndex,\n            container: this,\n            item\n        });\n        siblings.forEach((/**\n         * @param {?} sibling\n         * @param {?} index\n         * @return {?}\n         */\n        (sibling, index) => {\n            // Don't do anything if the position hasn't changed.\n            if (oldOrder[index] === sibling) {\n                return;\n            }\n            /** @type {?} */\n            const isDraggedItem = sibling.drag === item;\n            /** @type {?} */\n            const offset = isDraggedItem ? itemOffset : siblingOffset;\n            /** @type {?} */\n            const elementToOffset = isDraggedItem ? item.getPlaceholderElement() :\n                sibling.drag.getRootElement();\n            // Update the offset to reflect the new position.\n            sibling.offset += offset;\n            // Since we're moving the items with a `transform`, we need to adjust their cached\n            // client rects to reflect their new position, as well as swap their positions in the cache.\n            // Note that we shouldn't use `getBoundingClientRect` here to update the cache, because the\n            // elements may be mid-animation which will give us a wrong result.\n            if (isHorizontal) {\n                // Round the transforms since some browsers will\n                // blur the elements, for sub-pixel transforms.\n                elementToOffset.style.transform = `translate3d(${Math.round(sibling.offset)}px, 0, 0)`;\n                adjustClientRect(sibling.clientRect, 0, offset);\n            }\n            else {\n                elementToOffset.style.transform = `translate3d(0, ${Math.round(sibling.offset)}px, 0)`;\n                adjustClientRect(sibling.clientRect, offset, 0);\n            }\n        }));\n    }\n    /**\n     * Checks whether the user's pointer is close to the edges of either the\n     * viewport or the drop list and starts the auto-scroll sequence.\n     * @param {?} pointerX User's pointer position along the x axis.\n     * @param {?} pointerY User's pointer position along the y axis.\n     * @return {?}\n     */\n    _startScrollingIfNecessary(pointerX, pointerY) {\n        if (this.autoScrollDisabled) {\n            return;\n        }\n        /** @type {?} */\n        let scrollNode;\n        /** @type {?} */\n        let verticalScrollDirection = 0 /* NONE */;\n        /** @type {?} */\n        let horizontalScrollDirection = 0 /* NONE */;\n        // Check whether we should start scrolling the container.\n        if (this._isPointerNearDropContainer(pointerX, pointerY)) {\n            /** @type {?} */\n            const element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceElement\"])(this.element);\n            [verticalScrollDirection, horizontalScrollDirection] =\n                getElementScrollDirections(element, this._clientRect, pointerX, pointerY);\n            if (verticalScrollDirection || horizontalScrollDirection) {\n                scrollNode = element;\n            }\n        }\n        // @breaking-change 9.0.0 Remove null check for _viewportRuler once it's a required parameter.\n        // Otherwise check if we can start scrolling the viewport.\n        if (this._viewportRuler && !verticalScrollDirection && !horizontalScrollDirection) {\n            const { width, height } = this._viewportRuler.getViewportSize();\n            /** @type {?} */\n            const clientRect = { width, height, top: 0, right: width, bottom: height, left: 0 };\n            verticalScrollDirection = getVerticalScrollDirection(clientRect, pointerY);\n            horizontalScrollDirection = getHorizontalScrollDirection(clientRect, pointerX);\n            scrollNode = window;\n        }\n        if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection ||\n            horizontalScrollDirection !== this._horizontalScrollDirection ||\n            scrollNode !== this._scrollNode)) {\n            this._verticalScrollDirection = verticalScrollDirection;\n            this._horizontalScrollDirection = horizontalScrollDirection;\n            this._scrollNode = scrollNode;\n            if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {\n                // @breaking-change 9.0.0 Remove null check for `_ngZone` once it is made required.\n                if (this._ngZone) {\n                    this._ngZone.runOutsideAngular(this._startScrollInterval);\n                }\n                else {\n                    this._startScrollInterval();\n                }\n            }\n            else {\n                this._stopScrolling();\n            }\n        }\n    }\n    /**\n     * Stops any currently-running auto-scroll sequences.\n     * @return {?}\n     */\n    _stopScrolling() {\n        this._stopScrollTimers.next();\n    }\n    /**\n     * Caches the position of the drop list.\n     * @private\n     * @return {?}\n     */\n    _cacheOwnPosition() {\n        /** @type {?} */\n        const element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceElement\"])(this.element);\n        this._clientRect = getMutableClientRect(element);\n        this._scrollPosition = { top: element.scrollTop, left: element.scrollLeft };\n    }\n    /**\n     * Refreshes the position cache of the items and sibling containers.\n     * @private\n     * @return {?}\n     */\n    _cacheItemPositions() {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        this._itemPositions = this._activeDraggables.map((/**\n         * @param {?} drag\n         * @return {?}\n         */\n        drag => {\n            /** @type {?} */\n            const elementToMeasure = this._dragDropRegistry.isDragging(drag) ?\n                // If the element is being dragged, we have to measure the\n                // placeholder, because the element is hidden.\n                drag.getPlaceholderElement() :\n                drag.getRootElement();\n            return { drag, offset: 0, clientRect: getMutableClientRect(elementToMeasure) };\n        })).sort((/**\n         * @param {?} a\n         * @param {?} b\n         * @return {?}\n         */\n        (a, b) => {\n            return isHorizontal ? a.clientRect.left - b.clientRect.left :\n                a.clientRect.top - b.clientRect.top;\n        }));\n    }\n    /**\n     * Resets the container to its initial state.\n     * @private\n     * @return {?}\n     */\n    _reset() {\n        this._isDragging = false;\n        // TODO(crisbeto): may have to wait for the animations to finish.\n        this._activeDraggables.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        item => item.getRootElement().style.transform = ''));\n        this._siblings.forEach((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._stopReceiving(this)));\n        this._activeDraggables = [];\n        this._itemPositions = [];\n        this._previousSwap.drag = null;\n        this._previousSwap.delta = 0;\n        this._stopScrolling();\n        this._removeListeners();\n    }\n    /**\n     * Gets the offset in pixels by which the items that aren't being dragged should be moved.\n     * @private\n     * @param {?} currentIndex Index of the item currently being dragged.\n     * @param {?} siblings All of the items in the list.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    _getSiblingOffsetPx(currentIndex, siblings, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        const currentPosition = siblings[currentIndex].clientRect;\n        /** @type {?} */\n        const immediateSibling = siblings[currentIndex + delta * -1];\n        /** @type {?} */\n        let siblingOffset = currentPosition[isHorizontal ? 'width' : 'height'] * delta;\n        if (immediateSibling) {\n            /** @type {?} */\n            const start = isHorizontal ? 'left' : 'top';\n            /** @type {?} */\n            const end = isHorizontal ? 'right' : 'bottom';\n            // Get the spacing between the start of the current item and the end of the one immediately\n            // after it in the direction in which the user is dragging, or vice versa. We add it to the\n            // offset in order to push the element to where it will be when it's inline and is influenced\n            // by the `margin` of its siblings.\n            if (delta === -1) {\n                siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];\n            }\n            else {\n                siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];\n            }\n        }\n        return siblingOffset;\n    }\n    /**\n     * Checks whether the pointer coordinates are close to the drop container.\n     * @private\n     * @param {?} pointerX Coordinates along the X axis.\n     * @param {?} pointerY Coordinates along the Y axis.\n     * @return {?}\n     */\n    _isPointerNearDropContainer(pointerX, pointerY) {\n        const { top, right, bottom, left, width, height } = this._clientRect;\n        /** @type {?} */\n        const xThreshold = width * DROP_PROXIMITY_THRESHOLD;\n        /** @type {?} */\n        const yThreshold = height * DROP_PROXIMITY_THRESHOLD;\n        return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\n            pointerX > left - xThreshold && pointerX < right + xThreshold;\n    }\n    /**\n     * Gets the offset in pixels by which the item that is being dragged should be moved.\n     * @private\n     * @param {?} currentPosition Current position of the item.\n     * @param {?} newPosition Position of the item where the current item should be moved.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    _getItemOffsetPx(currentPosition, newPosition, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        let itemOffset = isHorizontal ? newPosition.left - currentPosition.left :\n            newPosition.top - currentPosition.top;\n        // Account for differences in the item width/height.\n        if (delta === -1) {\n            itemOffset += isHorizontal ? newPosition.width - currentPosition.width :\n                newPosition.height - currentPosition.height;\n        }\n        return itemOffset;\n    }\n    /**\n     * Gets the index of an item in the drop container, based on the position of the user's pointer.\n     * @private\n     * @param {?} item Item that is being sorted.\n     * @param {?} pointerX Position of the user's pointer along the X axis.\n     * @param {?} pointerY Position of the user's pointer along the Y axis.\n     * @param {?=} delta Direction in which the user is moving their pointer.\n     * @return {?}\n     */\n    _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        return findIndex(this._itemPositions, (/**\n         * @param {?} __0\n         * @param {?} _\n         * @param {?} array\n         * @return {?}\n         */\n        ({ drag, clientRect }, _, array) => {\n            if (drag === item) {\n                // If there's only one item left in the container, it must be\n                // the dragged item itself so we use it as a reference.\n                return array.length < 2;\n            }\n            if (delta) {\n                /** @type {?} */\n                const direction = isHorizontal ? delta.x : delta.y;\n                // If the user is still hovering over the same item as last time, and they didn't change\n                // the direction in which they're dragging, we don't consider it a direction swap.\n                if (drag === this._previousSwap.drag && direction === this._previousSwap.delta) {\n                    return false;\n                }\n            }\n            return isHorizontal ?\n                // Round these down since most browsers report client rects with\n                // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.\n                pointerX >= Math.floor(clientRect.left) && pointerX <= Math.floor(clientRect.right) :\n                pointerY >= Math.floor(clientRect.top) && pointerY <= Math.floor(clientRect.bottom);\n        }));\n    }\n    /**\n     * Caches the current items in the list and their positions.\n     * @private\n     * @return {?}\n     */\n    _cacheItems() {\n        this._activeDraggables = this._draggables.slice();\n        this._cacheItemPositions();\n        this._cacheOwnPosition();\n    }\n    /**\n     * Updates the internal state of the container after a scroll event has happened.\n     * @private\n     * @param {?} scrollPosition Object that is keeping track of the scroll position.\n     * @param {?} newTop New top scroll position.\n     * @param {?} newLeft New left scroll position.\n     * @param {?=} extraClientRect Extra `ClientRect` object that should be updated, in addition to the\n     *  ones of the drag items. Useful when the viewport has been scrolled and we also need to update\n     *  the `ClientRect` of the list.\n     * @return {?}\n     */\n    _updateAfterScroll(scrollPosition, newTop, newLeft, extraClientRect) {\n        /** @type {?} */\n        const topDifference = scrollPosition.top - newTop;\n        /** @type {?} */\n        const leftDifference = scrollPosition.left - newLeft;\n        if (extraClientRect) {\n            adjustClientRect(extraClientRect, topDifference, leftDifference);\n        }\n        // Since we know the amount that the user has scrolled we can shift all of the client rectangles\n        // ourselves. This is cheaper than re-measuring everything and we can avoid inconsistent\n        // behavior where we might be measuring the element before its position has changed.\n        this._itemPositions.forEach((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ({ clientRect }) => {\n            adjustClientRect(clientRect, topDifference, leftDifference);\n        }));\n        // We need two loops for this, because we want all of the cached\n        // positions to be up-to-date before we re-sort the item.\n        this._itemPositions.forEach((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ({ drag }) => {\n            if (this._dragDropRegistry.isDragging(drag)) {\n                // We need to re-sort the item manually, because the pointer move\n                // events won't be dispatched while the user is scrolling.\n                drag._sortFromLastPointerPosition();\n            }\n        }));\n        scrollPosition.top = newTop;\n        scrollPosition.left = newLeft;\n    }\n    /**\n     * Removes the event listeners associated with this drop list.\n     * @private\n     * @return {?}\n     */\n    _removeListeners() {\n        Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceElement\"])(this.element).removeEventListener('scroll', this._handleScroll);\n        this._viewportScrollSubscription.unsubscribe();\n    }\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param {?} x Pointer position along the X axis.\n     * @param {?} y Pointer position along the Y axis.\n     * @return {?}\n     */\n    _isOverContainer(x, y) {\n        return isInsideClientRect(this._clientRect, x, y);\n    }\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    _getSiblingContainerFromPosition(item, x, y) {\n        return this._siblings.find((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._canReceive(item, x, y)));\n    }\n    /**\n     * Checks whether the drop list can receive the passed-in item.\n     * @param {?} item Item that is being dragged into the list.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    _canReceive(item, x, y) {\n        if (!this.enterPredicate(item, this) || !isInsideClientRect(this._clientRect, x, y)) {\n            return false;\n        }\n        /** @type {?} */\n        const elementFromPoint = (/** @type {?} */ (this._shadowRoot.elementFromPoint(x, y)));\n        // If there's no element at the pointer position, then\n        // the client rect is probably scrolled out of the view.\n        if (!elementFromPoint) {\n            return false;\n        }\n        /** @type {?} */\n        const nativeElement = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceElement\"])(this.element);\n        // The `ClientRect`, that we're using to find the container over which the user is\n        // hovering, doesn't give us any information on whether the element has been scrolled\n        // out of the view or whether it's overlapping with other containers. This means that\n        // we could end up transferring the item into a container that's invisible or is positioned\n        // below another one. We use the result from `elementFromPoint` to get the top-most element\n        // at the pointer position and to find whether it's one of the intersecting drop containers.\n        return elementFromPoint === nativeElement || nativeElement.contains(elementFromPoint);\n    }\n    /**\n     * Called by one of the connected drop lists when a dragging sequence has started.\n     * @param {?} sibling Sibling in which dragging has started.\n     * @return {?}\n     */\n    _startReceiving(sibling) {\n        /** @type {?} */\n        const activeSiblings = this._activeSiblings;\n        if (!activeSiblings.has(sibling)) {\n            activeSiblings.add(sibling);\n            this._cacheOwnPosition();\n            this._listenToScrollEvents();\n        }\n    }\n    /**\n     * Called by a connected drop list when dragging has stopped.\n     * @param {?} sibling Sibling whose dragging has stopped.\n     * @return {?}\n     */\n    _stopReceiving(sibling) {\n        this._activeSiblings.delete(sibling);\n        this._viewportScrollSubscription.unsubscribe();\n    }\n    /**\n     * Starts listening to scroll events on the viewport.\n     * Used for updating the internal state of the list.\n     * @private\n     * @return {?}\n     */\n    _listenToScrollEvents() {\n        this._viewportScrollPosition = (/** @type {?} */ (this._viewportRuler)).getViewportScrollPosition();\n        this._viewportScrollSubscription = this._dragDropRegistry.scroll.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            if (this.isDragging()) {\n                /** @type {?} */\n                const newPosition = (/** @type {?} */ (this._viewportRuler)).getViewportScrollPosition();\n                this._updateAfterScroll(this._viewportScrollPosition, newPosition.top, newPosition.left, this._clientRect);\n            }\n            else if (this.isReceiving()) {\n                this._cacheOwnPosition();\n            }\n        }));\n    }\n}\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param {?} clientRect `ClientRect` that should be updated.\n * @param {?} top Amount to add to the `top` position.\n * @param {?} left Amount to add to the `left` position.\n * @return {?}\n */\nfunction adjustClientRect(clientRect, top, left) {\n    clientRect.top += top;\n    clientRect.bottom = clientRect.top + clientRect.height;\n    clientRect.left += left;\n    clientRect.right = clientRect.left + clientRect.width;\n}\n/**\n * Finds the index of an item that matches a predicate function. Used as an equivalent\n * of `Array.prototype.findIndex` which isn't part of the standard Google typings.\n * @template T\n * @param {?} array Array in which to look for matches.\n * @param {?} predicate Function used to determine whether an item is a match.\n * @return {?}\n */\nfunction findIndex(array, predicate) {\n    for (let i = 0; i < array.length; i++) {\n        if (predicate(array[i], i, array)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param {?} clientRect ClientRect that is being checked.\n * @param {?} x Coordinates along the X axis.\n * @param {?} y Coordinates along the Y axis.\n * @return {?}\n */\nfunction isInsideClientRect(clientRect, x, y) {\n    const { top, bottom, left, right } = clientRect;\n    return y >= top && y <= bottom && x >= left && x <= right;\n}\n/**\n * Gets a mutable version of an element's bounding `ClientRect`.\n * @param {?} element\n * @return {?}\n */\nfunction getMutableClientRect(element) {\n    /** @type {?} */\n    const clientRect = element.getBoundingClientRect();\n    // We need to clone the `clientRect` here, because all the values on it are readonly\n    // and we need to be able to update them. Also we can't use a spread here, because\n    // the values on a `ClientRect` aren't own properties. See:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n    return {\n        top: clientRect.top,\n        right: clientRect.right,\n        bottom: clientRect.bottom,\n        left: clientRect.left,\n        width: clientRect.width,\n        height: clientRect.height\n    };\n}\n/**\n * Increments the vertical scroll position of a node.\n * @param {?} node Node whose scroll position should change.\n * @param {?} amount Amount of pixels that the `node` should be scrolled.\n * @return {?}\n */\nfunction incrementVerticalScroll(node, amount) {\n    if (node === window) {\n        ((/** @type {?} */ (node))).scrollBy(0, amount);\n    }\n    else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        ((/** @type {?} */ (node))).scrollTop += amount;\n    }\n}\n/**\n * Increments the horizontal scroll position of a node.\n * @param {?} node Node whose scroll position should change.\n * @param {?} amount Amount of pixels that the `node` should be scrolled.\n * @return {?}\n */\nfunction incrementHorizontalScroll(node, amount) {\n    if (node === window) {\n        ((/** @type {?} */ (node))).scrollBy(amount, 0);\n    }\n    else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        ((/** @type {?} */ (node))).scrollLeft += amount;\n    }\n}\n/**\n * Gets whether the vertical auto-scroll direction of a node.\n * @param {?} clientRect Dimensions of the node.\n * @param {?} pointerY Position of the user's pointer along the y axis.\n * @return {?}\n */\nfunction getVerticalScrollDirection(clientRect, pointerY) {\n    const { top, bottom, height } = clientRect;\n    /** @type {?} */\n    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n        return 1 /* UP */;\n    }\n    else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n        return 2 /* DOWN */;\n    }\n    return 0 /* NONE */;\n}\n/**\n * Gets whether the horizontal auto-scroll direction of a node.\n * @param {?} clientRect Dimensions of the node.\n * @param {?} pointerX Position of the user's pointer along the x axis.\n * @return {?}\n */\nfunction getHorizontalScrollDirection(clientRect, pointerX) {\n    const { left, right, width } = clientRect;\n    /** @type {?} */\n    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n        return 1 /* LEFT */;\n    }\n    else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n        return 2 /* RIGHT */;\n    }\n    return 0 /* NONE */;\n}\n/**\n * Gets the directions in which an element node should be scrolled,\n * assuming that the user's pointer is already within it scrollable region.\n * @param {?} element Element for which we should calculate the scroll direction.\n * @param {?} clientRect Bounding client rectangle of the element.\n * @param {?} pointerX Position of the user's pointer along the x axis.\n * @param {?} pointerY Position of the user's pointer along the y axis.\n * @return {?}\n */\nfunction getElementScrollDirections(element, clientRect, pointerX, pointerY) {\n    /** @type {?} */\n    const computedVertical = getVerticalScrollDirection(clientRect, pointerY);\n    /** @type {?} */\n    const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);\n    /** @type {?} */\n    let verticalScrollDirection = 0 /* NONE */;\n    /** @type {?} */\n    let horizontalScrollDirection = 0 /* NONE */;\n    // Note that we here we do some extra checks for whether the element is actually scrollable in\n    // a certain direction and we only assign the scroll direction if it is. We do this so that we\n    // can allow other elements to be scrolled, if the current element can't be scrolled anymore.\n    // This allows us to handle cases where the scroll regions of two scrollable elements overlap.\n    if (computedVertical) {\n        /** @type {?} */\n        const scrollTop = element.scrollTop;\n        if (computedVertical === 1 /* UP */) {\n            if (scrollTop > 0) {\n                verticalScrollDirection = 1 /* UP */;\n            }\n        }\n        else if (element.scrollHeight - scrollTop > element.clientHeight) {\n            verticalScrollDirection = 2 /* DOWN */;\n        }\n    }\n    if (computedHorizontal) {\n        /** @type {?} */\n        const scrollLeft = element.scrollLeft;\n        if (computedHorizontal === 1 /* LEFT */) {\n            if (scrollLeft > 0) {\n                horizontalScrollDirection = 1 /* LEFT */;\n            }\n        }\n        else if (element.scrollWidth - scrollLeft > element.clientWidth) {\n            horizontalScrollDirection = 2 /* RIGHT */;\n        }\n    }\n    return [verticalScrollDirection, horizontalScrollDirection];\n}\n/**\n * Gets the shadow root of an element, if any.\n * @param {?} element\n * @return {?}\n */\nfunction getShadowRoot(element) {\n    if (Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__[\"_supportsShadowDom\"])()) {\n        /** @type {?} */\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\n        if (rootNode instanceof ShadowRoot) {\n            return rootNode;\n        }\n    }\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Event options that can be used to bind an active, capturing event.\n * @type {?}\n */\nconst activeCapturingEventOptions = Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__[\"normalizePassiveListenerOptions\"])({\n    passive: false,\n    capture: true\n});\n/**\n * Service that keeps track of all the drag item and drop container\n * instances, and manages global event listeners on the `document`.\n * \\@docs-private\n * @template I, C\n */\n// Note: this class is generic, rather than referencing CdkDrag and CdkDropList directly, in order\n// to avoid circular imports. If we were to reference them here, importing the registry into the\n// classes that are registering themselves will introduce a circular import.\nclass DragDropRegistry {\n    /**\n     * @param {?} _ngZone\n     * @param {?} _document\n     */\n    constructor(_ngZone, _document) {\n        this._ngZone = _ngZone;\n        /**\n         * Registered drop container instances.\n         */\n        this._dropInstances = new Set();\n        /**\n         * Registered drag item instances.\n         */\n        this._dragInstances = new Set();\n        /**\n         * Drag item instances that are currently being dragged.\n         */\n        this._activeDragInstances = new Set();\n        /**\n         * Keeps track of the event listeners that we've bound to the `document`.\n         */\n        this._globalListeners = new Map();\n        /**\n         * Emits the `touchmove` or `mousemove` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerMove = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Emits the `touchend` or `mouseup` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerUp = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Emits when the viewport has been scrolled while the user is dragging an item.\n         */\n        this.scroll = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Event listener that will prevent the default browser action while the user is dragging.\n         * @param event Event whose default action should be prevented.\n         */\n        this._preventDefaultWhileDragging = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            if (this._activeDragInstances.size) {\n                event.preventDefault();\n            }\n        });\n        this._document = _document;\n    }\n    /**\n     * Adds a drop container to the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    registerDropContainer(drop) {\n        if (!this._dropInstances.has(drop)) {\n            if (this.getDropContainer(drop.id)) {\n                throw Error(`Drop instance with id \"${drop.id}\" has already been registered.`);\n            }\n            this._dropInstances.add(drop);\n        }\n    }\n    /**\n     * Adds a drag item instance to the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    registerDragItem(drag) {\n        this._dragInstances.add(drag);\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\n        // won't preventDefault on a dynamically-added `touchmove` listener.\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n        if (this._dragInstances.size === 1) {\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                // The event handler has to be explicitly active,\n                // because newer browsers make it passive by default.\n                this._document.addEventListener('touchmove', this._preventDefaultWhileDragging, activeCapturingEventOptions);\n            }));\n        }\n    }\n    /**\n     * Removes a drop container from the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    removeDropContainer(drop) {\n        this._dropInstances.delete(drop);\n    }\n    /**\n     * Removes a drag item instance from the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    removeDragItem(drag) {\n        this._dragInstances.delete(drag);\n        this.stopDragging(drag);\n        if (this._dragInstances.size === 0) {\n            this._document.removeEventListener('touchmove', this._preventDefaultWhileDragging, activeCapturingEventOptions);\n        }\n    }\n    /**\n     * Starts the dragging sequence for a drag instance.\n     * @param {?} drag Drag instance which is being dragged.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    startDragging(drag, event) {\n        // Do not process the same drag twice to avoid memory leaks and redundant listeners\n        if (this._activeDragInstances.has(drag)) {\n            return;\n        }\n        this._activeDragInstances.add(drag);\n        if (this._activeDragInstances.size === 1) {\n            /** @type {?} */\n            const isTouchEvent = event.type.startsWith('touch');\n            /** @type {?} */\n            const moveEvent = isTouchEvent ? 'touchmove' : 'mousemove';\n            /** @type {?} */\n            const upEvent = isTouchEvent ? 'touchend' : 'mouseup';\n            // We explicitly bind __active__ listeners here, because newer browsers will default to\n            // passive ones for `mousemove` and `touchmove`. The events need to be active, because we\n            // use `preventDefault` to prevent the page from scrolling while the user is dragging.\n            this._globalListeners\n                .set(moveEvent, {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.pointerMove.next((/** @type {?} */ (e)))),\n                options: activeCapturingEventOptions\n            })\n                .set(upEvent, {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.pointerUp.next((/** @type {?} */ (e)))),\n                options: true\n            })\n                .set('scroll', {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.scroll.next(e)),\n                // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't\n                // the document. See https://github.com/angular/components/issues/17144.\n                options: true\n            })\n                // Preventing the default action on `mousemove` isn't enough to disable text selection\n                // on Safari so we need to prevent the selection event as well. Alternatively this can\n                // be done by setting `user-select: none` on the `body`, however it has causes a style\n                // recalculation which can be expensive on pages with a lot of elements.\n                .set('selectstart', {\n                handler: this._preventDefaultWhileDragging,\n                options: activeCapturingEventOptions\n            });\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                this._globalListeners.forEach((/**\n                 * @param {?} config\n                 * @param {?} name\n                 * @return {?}\n                 */\n                (config, name) => {\n                    this._document.addEventListener(name, config.handler, config.options);\n                }));\n            }));\n        }\n    }\n    /**\n     * Stops dragging a drag item instance.\n     * @param {?} drag\n     * @return {?}\n     */\n    stopDragging(drag) {\n        this._activeDragInstances.delete(drag);\n        if (this._activeDragInstances.size === 0) {\n            this._clearGlobalListeners();\n        }\n    }\n    /**\n     * Gets whether a drag item instance is currently being dragged.\n     * @param {?} drag\n     * @return {?}\n     */\n    isDragging(drag) {\n        return this._activeDragInstances.has(drag);\n    }\n    /**\n     * Gets a drop container by its id.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 8.0.0\n     * @param {?} id\n     * @return {?}\n     */\n    getDropContainer(id) {\n        return Array.from(this._dropInstances).find((/**\n         * @param {?} instance\n         * @return {?}\n         */\n        instance => instance.id === id));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._dragInstances.forEach((/**\n         * @param {?} instance\n         * @return {?}\n         */\n        instance => this.removeDragItem(instance)));\n        this._dropInstances.forEach((/**\n         * @param {?} instance\n         * @return {?}\n         */\n        instance => this.removeDropContainer(instance)));\n        this._clearGlobalListeners();\n        this.pointerMove.complete();\n        this.pointerUp.complete();\n    }\n    /**\n     * Clears out the global event listeners from the `document`.\n     * @private\n     * @return {?}\n     */\n    _clearGlobalListeners() {\n        this._globalListeners.forEach((/**\n         * @param {?} config\n         * @param {?} name\n         * @return {?}\n         */\n        (config, name) => {\n            this._document.removeEventListener(name, config.handler, config.options);\n        }));\n        this._globalListeners.clear();\n    }\n}\nDragDropRegistry.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Injectable\"], args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nDragDropRegistry.ctorParameters = () => [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"NgZone\"] },\n    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Inject\"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_5__[\"DOCUMENT\"],] }] }\n];\n/** @nocollapse */ DragDropRegistry.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__[\"defineInjectable\"])({ factory: function DragDropRegistry_Factory() { return new DragDropRegistry(Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__[\"inject\"])(_angular_core__WEBPACK_IMPORTED_MODULE_4__[\"NgZone\"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__[\"inject\"])(_angular_common__WEBPACK_IMPORTED_MODULE_5__[\"DOCUMENT\"])); }, token: DragDropRegistry, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Default configuration to be used when creating a `DragRef`.\n * @type {?}\n */\nconst DEFAULT_CONFIG = {\n    dragStartThreshold: 5,\n    pointerDirectionChangeThreshold: 5\n};\n/**\n * Service that allows for drag-and-drop functionality to be attached to DOM elements.\n */\nclass DragDrop {\n    /**\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewportRuler\n     * @param {?} _dragDropRegistry\n     */\n    constructor(_document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n    }\n    /**\n     * Turns an element into a draggable item.\n     * @template T\n     * @param {?} element Element to which to attach the dragging functionality.\n     * @param {?=} config Object used to configure the dragging behavior.\n     * @return {?}\n     */\n    createDrag(element, config = DEFAULT_CONFIG) {\n        return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry);\n    }\n    /**\n     * Turns an element into a drop list.\n     * @template T\n     * @param {?} element Element to which to attach the drop list functionality.\n     * @return {?}\n     */\n    createDropList(element) {\n        return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);\n    }\n}\nDragDrop.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Injectable\"], args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nDragDrop.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Inject\"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_5__[\"DOCUMENT\"],] }] },\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"NgZone\"] },\n    { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_6__[\"ViewportRuler\"] },\n    { type: DragDropRegistry }\n];\n/** @nocollapse */ DragDrop.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__[\"defineInjectable\"])({ factory: function DragDrop_Factory() { return new DragDrop(Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__[\"inject\"])(_angular_common__WEBPACK_IMPORTED_MODULE_5__[\"DOCUMENT\"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__[\"inject\"])(_angular_core__WEBPACK_IMPORTED_MODULE_4__[\"NgZone\"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__[\"inject\"])(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_6__[\"ViewportRuler\"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__[\"inject\"])(DragDropRegistry)); }, token: DragDrop, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that is used to provide a CdkDropList instance to CdkDrag.\n * Used for avoiding circular imports.\n * @type {?}\n */\nconst CDK_DROP_LIST = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"InjectionToken\"]('CDK_DROP_LIST');\n/**\n * Injection token that is used to provide a CdkDropList instance to CdkDrag.\n * Used for avoiding circular imports.\n * @deprecated Use `CDK_DROP_LIST` instead.\n * \\@breaking-change 8.0.0\n * @type {?}\n */\nconst CDK_DROP_LIST_CONTAINER = CDK_DROP_LIST;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that can be used for a `CdkDrag` to provide itself as a parent to the\n * drag-specific child directive (`CdkDragHandle`, `CdkDragPreview` etc.). Used primarily\n * to avoid circular imports.\n * \\@docs-private\n * @type {?}\n */\nconst CDK_DRAG_PARENT = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"InjectionToken\"]('CDK_DRAG_PARENT');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Handle that can be used to drag and CdkDrag instance.\n */\nclass CdkDragHandle {\n    /**\n     * @param {?} element\n     * @param {?=} parentDrag\n     */\n    constructor(element, parentDrag) {\n        this.element = element;\n        /**\n         * Emits when the state of the handle has changed.\n         */\n        this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        this._disabled = false;\n        this._parentDrag = parentDrag;\n        toggleNativeDragInteractions(element.nativeElement, false);\n    }\n    /**\n     * Whether starting to drag through this handle is disabled.\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceBooleanProperty\"])(value);\n        this._stateChanges.next(this);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._stateChanges.complete();\n    }\n}\nCdkDragHandle.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Directive\"], args: [{\n                selector: '[cdkDragHandle]',\n                host: {\n                    'class': 'cdk-drag-handle'\n                }\n            },] },\n];\n/** @nocollapse */\nCdkDragHandle.ctorParameters = () => [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"ElementRef\"] },\n    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Inject\"], args: [CDK_DRAG_PARENT,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Optional\"] }] }\n];\nCdkDragHandle.propDecorators = {\n    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDragHandleDisabled',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the placeholder of a CdkDrag when\n * it is being dragged. The placeholder is displayed in place of the element being dragged.\n * @template T\n */\nclass CdkDragPlaceholder {\n    /**\n     * @param {?} templateRef\n     */\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCdkDragPlaceholder.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Directive\"], args: [{\n                selector: 'ng-template[cdkDragPlaceholder]'\n            },] },\n];\n/** @nocollapse */\nCdkDragPlaceholder.ctorParameters = () => [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"TemplateRef\"] }\n];\nCdkDragPlaceholder.propDecorators = {\n    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the preview\n * of a CdkDrag when it is being dragged.\n * @template T\n */\nclass CdkDragPreview {\n    /**\n     * @param {?} templateRef\n     */\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCdkDragPreview.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Directive\"], args: [{\n                selector: 'ng-template[cdkDragPreview]'\n            },] },\n];\n/** @nocollapse */\nCdkDragPreview.ctorParameters = () => [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"TemplateRef\"] }\n];\nCdkDragPreview.propDecorators = {\n    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that can be used to configure the behavior of `CdkDrag`.\n * @type {?}\n */\nconst CDK_DRAG_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"InjectionToken\"]('CDK_DRAG_CONFIG', {\n    providedIn: 'root',\n    factory: CDK_DRAG_CONFIG_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction CDK_DRAG_CONFIG_FACTORY() {\n    return { dragStartThreshold: 5, pointerDirectionChangeThreshold: 5 };\n}\n/**\n * Element that can be moved inside a CdkDropList container.\n * @template T\n */\nclass CdkDrag {\n    /**\n     * @param {?} element\n     * @param {?} dropContainer\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewContainerRef\n     * @param {?} config\n     * @param {?} _dir\n     * @param {?} dragDrop\n     * @param {?} _changeDetectorRef\n     */\n    constructor(element, dropContainer, _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef) {\n        this.element = element;\n        this.dropContainer = dropContainer;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewContainerRef = _viewContainerRef;\n        this._dir = _dir;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Amount of milliseconds to wait after the user has put their\n         * pointer down before starting to drag the element.\n         */\n        this.dragStartDelay = 0;\n        this._disabled = false;\n        /**\n         * Emits when the user starts dragging the item.\n         */\n        this.started = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"EventEmitter\"]();\n        /**\n         * Emits when the user has released a drag item, before any animations have started.\n         */\n        this.released = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"EventEmitter\"]();\n        /**\n         * Emits when the user stops dragging an item in the container.\n         */\n        this.ended = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"EventEmitter\"]();\n        /**\n         * Emits when the user has moved the item into a new container.\n         */\n        this.entered = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"EventEmitter\"]();\n        /**\n         * Emits when the user removes the item its container by dragging it into another container.\n         */\n        this.exited = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"EventEmitter\"]();\n        /**\n         * Emits when the user drops the item inside a container.\n         */\n        this.dropped = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"EventEmitter\"]();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Observable\"]((/**\n         * @param {?} observer\n         * @return {?}\n         */\n        (observer) => {\n            /** @type {?} */\n            const subscription = this._dragRef.moved.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[\"map\"])((/**\n             * @param {?} movedEvent\n             * @return {?}\n             */\n            movedEvent => ({\n                source: this,\n                pointerPosition: movedEvent.pointerPosition,\n                event: movedEvent.event,\n                delta: movedEvent.delta,\n                distance: movedEvent.distance\n            })))).subscribe(observer);\n            return (/**\n             * @return {?}\n             */\n            () => {\n                subscription.unsubscribe();\n            });\n        }));\n        this._dragRef = dragDrop.createDrag(element, config);\n        this._dragRef.data = this;\n        this._syncInputs(this._dragRef);\n        this._handleEvents(this._dragRef);\n    }\n    /**\n     * Selector that will be used to determine the element to which the draggable's position will\n     * be constrained. Matching starts from the element's parent and goes up the DOM until a matching\n     * element has been found\n     * @deprecated Use `boundaryElement` instead.\n     * \\@breaking-change 9.0.0\n     * @return {?}\n     */\n    get boundaryElementSelector() {\n        return typeof this.boundaryElement === 'string' ? this.boundaryElement : (/** @type {?} */ (undefined));\n    }\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    set boundaryElementSelector(selector) {\n        this.boundaryElement = selector;\n    }\n    /**\n     * Whether starting to drag this element is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || (this.dropContainer && this.dropContainer.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceBooleanProperty\"])(value);\n        this._dragRef.disabled = this._disabled;\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    getPlaceholderElement() {\n        return this._dragRef.getPlaceholderElement();\n    }\n    /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    getRootElement() {\n        return this._dragRef.getRootElement();\n    }\n    /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    reset() {\n        this._dragRef.reset();\n    }\n    /**\n     * Gets the pixel coordinates of the draggable outside of a drop container.\n     * @return {?}\n     */\n    getFreeDragPosition() {\n        return this._dragRef.getFreeDragPosition();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        // We need to wait for the zone to stabilize, in order for the reference\n        // element to be in the proper place in the DOM. This is mostly relevant\n        // for draggable elements inside portals since they get stamped out in\n        // their original DOM position and then they get transferred to the portal.\n        this._ngZone.onStable.asObservable()\n            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[\"take\"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[\"takeUntil\"])(this._destroyed))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._updateRootElement();\n            // Listen for any newly-added handles.\n            this._handles.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[\"startWith\"])(this._handles), \n            // Sync the new handles with the DragRef.\n            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[\"tap\"])((/**\n             * @param {?} handles\n             * @return {?}\n             */\n            (handles) => {\n                /** @type {?} */\n                const childHandleElements = handles\n                    .filter((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => handle._parentDrag === this))\n                    .map((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => handle.element));\n                this._dragRef.withHandles(childHandleElements);\n            })), \n            // Listen if the state of any of the handles changes.\n            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[\"switchMap\"])((/**\n             * @param {?} handles\n             * @return {?}\n             */\n            (handles) => {\n                return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[\"merge\"])(...handles.map((/**\n                 * @param {?} item\n                 * @return {?}\n                 */\n                item => item._stateChanges)));\n            })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[\"takeUntil\"])(this._destroyed)).subscribe((/**\n             * @param {?} handleInstance\n             * @return {?}\n             */\n            handleInstance => {\n                // Enabled/disable the handle that changed in the DragRef.\n                /** @type {?} */\n                const dragRef = this._dragRef;\n                /** @type {?} */\n                const handle = handleInstance.element.nativeElement;\n                handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);\n            }));\n            if (this.freeDragPosition) {\n                this._dragRef.setFreeDragPosition(this.freeDragPosition);\n            }\n        }));\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        /** @type {?} */\n        const rootSelectorChange = changes['rootElementSelector'];\n        /** @type {?} */\n        const positionChange = changes['freeDragPosition'];\n        // We don't have to react to the first change since it's being\n        // handled in `ngAfterViewInit` where it needs to be deferred.\n        if (rootSelectorChange && !rootSelectorChange.firstChange) {\n            this._updateRootElement();\n        }\n        // Skip the first change since it's being handled in `ngAfterViewInit`.\n        if (positionChange && !positionChange.firstChange && this.freeDragPosition) {\n            this._dragRef.setFreeDragPosition(this.freeDragPosition);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n        this._dragRef.dispose();\n    }\n    /**\n     * Syncs the root element with the `DragRef`.\n     * @private\n     * @return {?}\n     */\n    _updateRootElement() {\n        /** @type {?} */\n        const element = this.element.nativeElement;\n        /** @type {?} */\n        const rootElement = this.rootElementSelector ?\n            getClosestMatchingAncestor(element, this.rootElementSelector) : element;\n        if (rootElement && rootElement.nodeType !== this._document.ELEMENT_NODE) {\n            throw Error(`cdkDrag must be attached to an element node. ` +\n                `Currently attached to \"${rootElement.nodeName}\".`);\n        }\n        this._dragRef.withRootElement(rootElement || element);\n    }\n    /**\n     * Gets the boundary element, based on the `boundaryElement` value.\n     * @private\n     * @return {?}\n     */\n    _getBoundaryElement() {\n        /** @type {?} */\n        const boundary = this.boundaryElement;\n        if (!boundary) {\n            return null;\n        }\n        if (typeof boundary === 'string') {\n            return getClosestMatchingAncestor(this.element.nativeElement, boundary);\n        }\n        /** @type {?} */\n        const element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceElement\"])(boundary);\n        if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__[\"isDevMode\"])() && !element.contains(this.element.nativeElement)) {\n            throw Error('Draggable element is not inside of the node passed into cdkDragBoundary.');\n        }\n        return element;\n    }\n    /**\n     * Syncs the inputs of the CdkDrag with the options of the underlying DragRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _syncInputs(ref) {\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            if (!ref.isDragging()) {\n                /** @type {?} */\n                const dir = this._dir;\n                /** @type {?} */\n                const placeholder = this._placeholderTemplate ? {\n                    template: this._placeholderTemplate.templateRef,\n                    context: this._placeholderTemplate.data,\n                    viewContainer: this._viewContainerRef\n                } : null;\n                /** @type {?} */\n                const preview = this._previewTemplate ? {\n                    template: this._previewTemplate.templateRef,\n                    context: this._previewTemplate.data,\n                    viewContainer: this._viewContainerRef\n                } : null;\n                ref.disabled = this.disabled;\n                ref.lockAxis = this.lockAxis;\n                ref.dragStartDelay = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceNumberProperty\"])(this.dragStartDelay);\n                ref.constrainPosition = this.constrainPosition;\n                ref\n                    .withBoundaryElement(this._getBoundaryElement())\n                    .withPlaceholderTemplate(placeholder)\n                    .withPreviewTemplate(preview);\n                if (dir) {\n                    ref.withDirection(dir.value);\n                }\n            }\n        }));\n    }\n    /**\n     * Handles the events from the underlying `DragRef`.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _handleEvents(ref) {\n        ref.started.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.started.emit({ source: this });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.released.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.released.emit({ source: this });\n        }));\n        ref.ended.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.ended.emit({ source: this, distance: event.distance });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.entered.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.entered.emit({\n                container: event.container.data,\n                item: this,\n                currentIndex: event.currentIndex\n            });\n        }));\n        ref.exited.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.exited.emit({\n                container: event.container.data,\n                item: this\n            });\n        }));\n        ref.dropped.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.dropped.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                previousContainer: event.previousContainer.data,\n                container: event.container.data,\n                isPointerOverContainer: event.isPointerOverContainer,\n                item: this,\n                distance: event.distance\n            });\n        }));\n    }\n}\nCdkDrag.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Directive\"], args: [{\n                selector: '[cdkDrag]',\n                exportAs: 'cdkDrag',\n                host: {\n                    'class': 'cdk-drag',\n                    '[class.cdk-drag-disabled]': 'disabled',\n                    '[class.cdk-drag-dragging]': '_dragRef.isDragging()',\n                },\n                providers: [{ provide: CDK_DRAG_PARENT, useExisting: CdkDrag }]\n            },] },\n];\n/** @nocollapse */\nCdkDrag.ctorParameters = () => [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"ElementRef\"] },\n    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Inject\"], args: [CDK_DROP_LIST,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Optional\"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"SkipSelf\"] }] },\n    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Inject\"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_5__[\"DOCUMENT\"],] }] },\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"NgZone\"] },\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"ViewContainerRef\"] },\n    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Inject\"], args: [CDK_DRAG_CONFIG,] }] },\n    { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__[\"Directionality\"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Optional\"] }] },\n    { type: DragDrop },\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"ChangeDetectorRef\"] }\n];\nCdkDrag.propDecorators = {\n    _handles: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"ContentChildren\"], args: [CdkDragHandle, { descendants: true },] }],\n    _previewTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"ContentChild\"], args: [CdkDragPreview, { static: false },] }],\n    _placeholderTemplate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"ContentChild\"], args: [CdkDragPlaceholder, { static: false },] }],\n    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDragData',] }],\n    lockAxis: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDragLockAxis',] }],\n    rootElementSelector: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDragRootElement',] }],\n    boundaryElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDragBoundary',] }],\n    dragStartDelay: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDragStartDelay',] }],\n    freeDragPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDragFreeDragPosition',] }],\n    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDragDisabled',] }],\n    constrainPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDragConstrainPosition',] }],\n    started: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Output\"], args: ['cdkDragStarted',] }],\n    released: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Output\"], args: ['cdkDragReleased',] }],\n    ended: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Output\"], args: ['cdkDragEnded',] }],\n    entered: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Output\"], args: ['cdkDragEntered',] }],\n    exited: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Output\"], args: ['cdkDragExited',] }],\n    dropped: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Output\"], args: ['cdkDragDropped',] }],\n    moved: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Output\"], args: ['cdkDragMoved',] }]\n};\n/**\n * Gets the closest ancestor of an element that matches a selector.\n * @param {?} element\n * @param {?} selector\n * @return {?}\n */\nfunction getClosestMatchingAncestor(element, selector) {\n    /** @type {?} */\n    let currentElement = (/** @type {?} */ (element.parentElement));\n    while (currentElement) {\n        // IE doesn't support `matches` so we have to fall back to `msMatchesSelector`.\n        if (currentElement.matches ? currentElement.matches(selector) :\n            ((/** @type {?} */ (currentElement))).msMatchesSelector(selector)) {\n            return currentElement;\n        }\n        currentElement = currentElement.parentElement;\n    }\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Declaratively connects sibling `cdkDropList` instances together. All of the `cdkDropList`\n * elements that are placed inside a `cdkDropListGroup` will be connected to each other\n * automatically. Can be used as an alternative to the `cdkDropListConnectedTo` input\n * from `cdkDropList`.\n * @template T\n */\nclass CdkDropListGroup {\n    constructor() {\n        /**\n         * Drop lists registered inside the group.\n         */\n        this._items = new Set();\n        this._disabled = false;\n    }\n    /**\n     * Whether starting a dragging sequence from inside this group is disabled.\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceBooleanProperty\"])(value);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._items.clear();\n    }\n}\nCdkDropListGroup.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Directive\"], args: [{\n                selector: '[cdkDropListGroup]',\n                exportAs: 'cdkDropListGroup',\n            },] },\n];\nCdkDropListGroup.propDecorators = {\n    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDropListGroupDisabled',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Counter used to generate unique ids for drop zones.\n * @type {?}\n */\nlet _uniqueIdCounter$1 = 0;\nconst 0 = undefined;\n// @breaking-change 8.0.0 `CdkDropList` implements `CdkDropListContainer` for backwards\n// compatiblity. The implements clause, as well as all the methods that it enforces can\n// be removed when `CdkDropListContainer` is deleted.\n/**\n * Container that wraps a set of draggable items.\n * @template T\n */\nclass CdkDropList {\n    /**\n     * @param {?} element\n     * @param {?} dragDrop\n     * @param {?} _changeDetectorRef\n     * @param {?=} _dir\n     * @param {?=} _group\n     */\n    constructor(element, dragDrop, _changeDetectorRef, _dir, _group) {\n        this.element = element;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = _dir;\n        this._group = _group;\n        /**\n         * Emits when the list has been destroyed.\n         */\n        this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_2__[\"Subject\"]();\n        /**\n         * Other draggable containers that this container is connected to and into which the\n         * container's items can be transferred. Can either be references to other drop containers,\n         * or their unique IDs.\n         */\n        this.connectedTo = [];\n        /**\n         * Direction in which the list is oriented.\n         */\n        this.orientation = 'vertical';\n        /**\n         * Unique ID for the drop zone. Can be used as a reference\n         * in the `connectedTo` of another `CdkDropList`.\n         */\n        this.id = `cdk-drop-list-${_uniqueIdCounter$1++}`;\n        this._disabled = false;\n        this._sortingDisabled = false;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = (/**\n         * @return {?}\n         */\n        () => true);\n        /**\n         * Whether to auto-scroll the view when the user moves their pointer close to the edges.\n         */\n        this.autoScrollDisabled = false;\n        /**\n         * Emits when the user drops an item inside the container.\n         */\n        this.dropped = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"EventEmitter\"]();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"EventEmitter\"]();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"EventEmitter\"]();\n        /**\n         * Emits as the user is swapping items while actively dragging.\n         */\n        this.sorted = new _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"EventEmitter\"]();\n        this._dropListRef = dragDrop.createDropList(element);\n        this._dropListRef.data = this;\n        this._dropListRef.enterPredicate = (/**\n         * @param {?} drag\n         * @param {?} drop\n         * @return {?}\n         */\n        (drag, drop) => {\n            return this.enterPredicate(drag.data, drop.data);\n        });\n        this._syncInputs(this._dropListRef);\n        this._handleEvents(this._dropListRef);\n        CdkDropList._dropLists.push(this);\n        if (_group) {\n            _group._items.add(this);\n        }\n    }\n    /**\n     * Whether starting a dragging sequence from this container is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || (!!this._group && this._group.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceBooleanProperty\"])(value);\n    }\n    /**\n     * Whether sorting within this drop list is disabled.\n     * @return {?}\n     */\n    get sortingDisabled() { return this._sortingDisabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set sortingDisabled(value) {\n        this._sortingDisabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceBooleanProperty\"])(value);\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._draggables.changes\n            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[\"startWith\"])(this._draggables), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[\"takeUntil\"])(this._destroyed))\n            .subscribe((/**\n         * @param {?} items\n         * @return {?}\n         */\n        (items) => {\n            this._dropListRef.withItems(items.map((/**\n             * @param {?} drag\n             * @return {?}\n             */\n            drag => drag._dragRef)));\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        /** @type {?} */\n        const index = CdkDropList._dropLists.indexOf(this);\n        if (index > -1) {\n            CdkDropList._dropLists.splice(index, 1);\n        }\n        if (this._group) {\n            this._group._items.delete(this);\n        }\n        this._dropListRef.dispose();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    start() {\n        this._dropListRef.start();\n    }\n    /**\n     * Drops an item into this container.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @return {?}\n     */\n    drop(item, currentIndex, previousContainer, isPointerOverContainer) {\n        this._dropListRef.drop(item._dragRef, currentIndex, ((/** @type {?} */ (previousContainer)))._dropListRef, isPointerOverContainer);\n    }\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    enter(item, pointerX, pointerY) {\n        this._dropListRef.enter(item._dragRef, pointerX, pointerY);\n    }\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    exit(item) {\n        this._dropListRef.exit(item._dragRef);\n    }\n    /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    getItemIndex(item) {\n        return this._dropListRef.getItemIndex(item._dragRef);\n    }\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta Direction in which the pointer is moving along each axis.\n     * @return {?}\n     */\n    _sortItem(item, pointerX, pointerY, pointerDelta) {\n        return this._dropListRef._sortItem(item._dragRef, pointerX, pointerY, pointerDelta);\n    }\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    _getSiblingContainerFromPosition(item, x, y) {\n        /** @type {?} */\n        const result = this._dropListRef._getSiblingContainerFromPosition(item._dragRef, x, y);\n        return result ? result.data : null;\n    }\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param {?} x Pointer position along the X axis.\n     * @param {?} y Pointer position along the Y axis.\n     * @return {?}\n     */\n    _isOverContainer(x, y) {\n        return this._dropListRef._isOverContainer(x, y);\n    }\n    /**\n     * Syncs the inputs of the CdkDropList with the options of the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _syncInputs(ref) {\n        if (this._dir) {\n            this._dir.change\n                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[\"startWith\"])(this._dir.value), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[\"takeUntil\"])(this._destroyed))\n                .subscribe((/**\n             * @param {?} value\n             * @return {?}\n             */\n            value => ref.withDirection(value)));\n        }\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const siblings = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[\"coerceArray\"])(this.connectedTo).map((/**\n             * @param {?} drop\n             * @return {?}\n             */\n            drop => {\n                return typeof drop === 'string' ?\n                    (/** @type {?} */ (CdkDropList._dropLists.find((/**\n                     * @param {?} list\n                     * @return {?}\n                     */\n                    list => list.id === drop)))) : drop;\n            }));\n            if (this._group) {\n                this._group._items.forEach((/**\n                 * @param {?} drop\n                 * @return {?}\n                 */\n                drop => {\n                    if (siblings.indexOf(drop) === -1) {\n                        siblings.push(drop);\n                    }\n                }));\n            }\n            ref.disabled = this.disabled;\n            ref.lockAxis = this.lockAxis;\n            ref.sortingDisabled = this.sortingDisabled;\n            ref.autoScrollDisabled = this.autoScrollDisabled;\n            ref\n                .connectedTo(siblings.filter((/**\n             * @param {?} drop\n             * @return {?}\n             */\n            drop => drop && drop !== this)).map((/**\n             * @param {?} list\n             * @return {?}\n             */\n            list => list._dropListRef)))\n                .withOrientation(this.orientation);\n        }));\n    }\n    /**\n     * Handles events from the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _handleEvents(ref) {\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.entered.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.entered.emit({\n                container: this,\n                item: event.item.data,\n                currentIndex: event.currentIndex\n            });\n        }));\n        ref.exited.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.exited.emit({\n                container: this,\n                item: event.item.data\n            });\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.sorted.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.sorted.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                container: this,\n                item: event.item.data\n            });\n        }));\n        ref.dropped.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.dropped.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                previousContainer: event.previousContainer.data,\n                container: event.container.data,\n                item: event.item.data,\n                isPointerOverContainer: event.isPointerOverContainer,\n                distance: event.distance\n            });\n            // Mark for check since all of these events run outside of change\n            // detection and we're not guaranteed for something else to have triggered it.\n            this._changeDetectorRef.markForCheck();\n        }));\n    }\n}\n/**\n * Keeps track of the drop lists that are currently on the page.\n */\nCdkDropList._dropLists = [];\nCdkDropList.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Directive\"], args: [{\n                selector: '[cdkDropList], cdk-drop-list',\n                exportAs: 'cdkDropList',\n                providers: [\n                    // Prevent child drop lists from picking up the same group as their parent.\n                    { provide: CdkDropListGroup, useValue: 0 },\n                    { provide: CDK_DROP_LIST_CONTAINER, useExisting: CdkDropList },\n                ],\n                host: {\n                    'class': 'cdk-drop-list',\n                    '[id]': 'id',\n                    '[class.cdk-drop-list-disabled]': 'disabled',\n                    '[class.cdk-drop-list-dragging]': '_dropListRef.isDragging()',\n                    '[class.cdk-drop-list-receiving]': '_dropListRef.isReceiving()',\n                }\n            },] },\n];\n/** @nocollapse */\nCdkDropList.ctorParameters = () => [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"ElementRef\"] },\n    { type: DragDrop },\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"ChangeDetectorRef\"] },\n    { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__[\"Directionality\"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Optional\"] }] },\n    { type: CdkDropListGroup, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Optional\"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"SkipSelf\"] }] }\n];\nCdkDropList.propDecorators = {\n    _draggables: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"ContentChildren\"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__[\"forwardRef\"])((/**\n                 * @return {?}\n                 */\n                () => CdkDrag)), {\n                    // Explicitly set to false since some of the logic below makes assumptions about it.\n                    // The `.withItems` call below should be updated if we ever need to switch this to `true`.\n                    descendants: false\n                },] }],\n    connectedTo: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDropListConnectedTo',] }],\n    data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDropListData',] }],\n    orientation: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDropListOrientation',] }],\n    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"] }],\n    lockAxis: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDropListLockAxis',] }],\n    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDropListDisabled',] }],\n    sortingDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDropListSortingDisabled',] }],\n    enterPredicate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDropListEnterPredicate',] }],\n    autoScrollDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], args: ['cdkDropListAutoScrollDisabled',] }],\n    dropped: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Output\"], args: ['cdkDropListDropped',] }],\n    entered: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Output\"], args: ['cdkDropListEntered',] }],\n    exited: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Output\"], args: ['cdkDropListExited',] }],\n    sorted: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"Output\"], args: ['cdkDropListSorted',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass DragDropModule {\n}\nDragDropModule.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__[\"NgModule\"], args: [{\n                declarations: [\n                    CdkDropList,\n                    CdkDropListGroup,\n                    CdkDrag,\n                    CdkDragHandle,\n                    CdkDragPreview,\n                    CdkDragPlaceholder,\n                ],\n                exports: [\n                    CdkDropList,\n                    CdkDropListGroup,\n                    CdkDrag,\n                    CdkDragHandle,\n                    CdkDragPreview,\n                    CdkDragPlaceholder,\n                ],\n                providers: [\n                    DragDrop,\n                ]\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\n//# sourceMappingURL=drag-drop.js.map\n\n\n/***/ }),\n\n/***/ \"./node_modules/raw-loader/dist/cjs.js!./src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.page.html\":\n/*!*******************************************************************************************************************************!*\\\n  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.page.html ***!\n  \\*******************************************************************************************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"<ion-header>\\r\\n  <ion-toolbar>\\r\\n    <ion-buttons slot=\\\"start\\\">\\r\\n      <ion-back-button></ion-back-button>\\r\\n    </ion-buttons>\\r\\n    <ion-title>Drag Drop</ion-title>\\r\\n  </ion-toolbar>\\r\\n</ion-header>\\r\\n\\r\\n<ion-content class=\\\"ion-padding\\\">\\r\\n  <div class=\\\"example-container\\\">\\r\\n    <h2>To do</h2>\\r\\n\\r\\n    <div cdkDropList #todoList=\\\"cdkDropList\\\" [cdkDropListData]=\\\"todo\\\" [cdkDropListConnectedTo]=\\\"[doneList]\\\"\\r\\n      class=\\\"example-list\\\" (cdkDropListDropped)=\\\"drop($event)\\\">\\r\\n      <div class=\\\"example-box\\\" *ngFor=\\\"let item of todo\\\" cdkDrag>{{item}}</div>\\r\\n    </div>\\r\\n  </div>\\r\\n\\r\\n  <div class=\\\"example-container\\\">\\r\\n    <h2>Done</h2>\\r\\n\\r\\n    <div cdkDropList #doneList=\\\"cdkDropList\\\" [cdkDropListData]=\\\"done\\\" [cdkDropListConnectedTo]=\\\"[todoList]\\\"\\r\\n      class=\\\"example-list\\\" (cdkDropListDropped)=\\\"drop($event)\\\">\\r\\n      <div class=\\\"example-box\\\" *ngFor=\\\"let item of done\\\" cdkDrag>{{item}}</div>\\r\\n    </div>\\r\\n  </div>\\r\\n\\r\\n  <div class=\\\"example-box-basic\\\" cdkDrag>\\r\\n    Drag me around\\r\\n  </div>\\r\\n</ion-content>\");\n\n/***/ }),\n\n/***/ \"./src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.module.ts\":\n/*!*****************************************************************************************!*\\\n  !*** ./src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.module.ts ***!\n  \\*****************************************************************************************/\n/*! exports provided: MatDragDropPageModule */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MatDragDropPageModule\", function() { return MatDragDropPageModule; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm2015/core.js\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ \"./node_modules/@angular/common/fesm2015/common.js\");\n/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/forms */ \"./node_modules/@angular/forms/fesm2015/forms.js\");\n/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/router */ \"./node_modules/@angular/router/fesm2015/router.js\");\n/* harmony import */ var _ionic_angular__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ionic/angular */ \"./node_modules/@ionic/angular/dist/fesm5.js\");\n/* harmony import */ var _mat_drag_drop_page__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mat-drag-drop.page */ \"./src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.page.ts\");\n/* harmony import */ var _angular_cdk_drag_drop__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/drag-drop */ \"./node_modules/@angular/cdk/esm2015/drag-drop.js\");\n\n\n\n\n\n\n\n\nconst routes = [\n    {\n        path: '',\n        component: _mat_drag_drop_page__WEBPACK_IMPORTED_MODULE_6__[\"MatDragDropPage\"]\n    }\n];\nlet MatDragDropPageModule = class MatDragDropPageModule {\n};\nMatDragDropPageModule = tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([\n    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"NgModule\"])({\n        imports: [\n            _angular_common__WEBPACK_IMPORTED_MODULE_2__[\"CommonModule\"],\n            _angular_forms__WEBPACK_IMPORTED_MODULE_3__[\"FormsModule\"],\n            _ionic_angular__WEBPACK_IMPORTED_MODULE_5__[\"IonicModule\"],\n            _angular_router__WEBPACK_IMPORTED_MODULE_4__[\"RouterModule\"].forChild(routes),\n            _angular_cdk_drag_drop__WEBPACK_IMPORTED_MODULE_7__[\"DragDropModule\"]\n        ],\n        declarations: [_mat_drag_drop_page__WEBPACK_IMPORTED_MODULE_6__[\"MatDragDropPage\"]]\n    })\n], MatDragDropPageModule);\n\n\n\n/***/ }),\n\n/***/ \"./src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.page.scss\":\n/*!*****************************************************************************************!*\\\n  !*** ./src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.page.scss ***!\n  \\*****************************************************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\".example-container {\\n  width: 400px;\\n  max-width: 100%;\\n  margin: 0 25px 25px 0;\\n  display: inline-block;\\n  vertical-align: top;\\n}\\n\\n.example-list {\\n  border: solid 1px #ccc;\\n  min-height: 60px;\\n  background: white;\\n  border-radius: 4px;\\n  overflow: hidden;\\n  display: block;\\n}\\n\\n.example-box {\\n  padding: 20px 10px;\\n  border-bottom: solid 1px #ccc;\\n  color: rgba(0, 0, 0, 0.87);\\n  display: flex;\\n  flex-direction: row;\\n  align-items: center;\\n  justify-content: space-between;\\n  box-sizing: border-box;\\n  cursor: move;\\n  background: white;\\n  font-size: 14px;\\n}\\n\\n.cdk-drag-preview {\\n  box-sizing: border-box;\\n  border-radius: 4px;\\n  box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);\\n}\\n\\n.cdk-drag-placeholder {\\n  opacity: 0;\\n}\\n\\n.cdk-drag-animating {\\n  transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);\\n}\\n\\n.example-box:last-child {\\n  border: none;\\n}\\n\\n.example-list.cdk-drop-list-dragging .example-box:not(.cdk-drag-placeholder) {\\n  transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);\\n}\\n\\n.example-box-basic:active {\\n  box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);\\n}\\n\\n.example-box-basic {\\n  width: 200px;\\n  height: 200px;\\n  border: solid 1px #ccc;\\n  color: rgba(0, 0, 0, 0.87);\\n  cursor: move;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  text-align: center;\\n  background: #fff;\\n  border-radius: 4px;\\n  position: relative;\\n  z-index: 1;\\n  transition: box-shadow 200ms cubic-bezier(0, 0, 0.2, 1);\\n  box-shadow: 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);\\n}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvcGFnZXMvYW5ndWxhci1tYXRlcmlhbC9jb21wb25lbnRzL21hdC1kcmFnLWRyb3AvQzpcXFVzZXJzXFxzYWJhZGlcXERvY3VtZW50c1xcUHJvamV0b3NcXF9pb25pY1xcaW9uaWM0LWNvbXBvbmVudHMvc3JjXFxhcHBcXHBhZ2VzXFxhbmd1bGFyLW1hdGVyaWFsXFxjb21wb25lbnRzXFxtYXQtZHJhZy1kcm9wXFxtYXQtZHJhZy1kcm9wLnBhZ2Uuc2NzcyIsInNyYy9hcHAvcGFnZXMvYW5ndWxhci1tYXRlcmlhbC9jb21wb25lbnRzL21hdC1kcmFnLWRyb3AvbWF0LWRyYWctZHJvcC5wYWdlLnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxZQUFBO0VBQ0EsZUFBQTtFQUNBLHFCQUFBO0VBQ0EscUJBQUE7RUFDQSxtQkFBQTtBQ0NGOztBREVBO0VBQ0Usc0JBQUE7RUFDQSxnQkFBQTtFQUNBLGlCQUFBO0VBQ0Esa0JBQUE7RUFDQSxnQkFBQTtFQUNBLGNBQUE7QUNDRjs7QURFQTtFQUNFLGtCQUFBO0VBQ0EsNkJBQUE7RUFDQSwwQkFBQTtFQUNBLGFBQUE7RUFDQSxtQkFBQTtFQUNBLG1CQUFBO0VBQ0EsOEJBQUE7RUFDQSxzQkFBQTtFQUNBLFlBQUE7RUFDQSxpQkFBQTtFQUNBLGVBQUE7QUNDRjs7QURFQTtFQUNFLHNCQUFBO0VBQ0Esa0JBQUE7RUFDQSxxSEFBQTtBQ0NGOztBREVBO0VBQ0UsVUFBQTtBQ0NGOztBREVBO0VBQ0Usc0RBQUE7QUNDRjs7QURFQTtFQUNFLFlBQUE7QUNDRjs7QURFQTtFQUNFLHNEQUFBO0FDQ0Y7O0FERUE7RUFDRSxxSEFBQTtBQ0NGOztBREVBO0VBQ0UsWUFBQTtFQUNBLGFBQUE7RUFDQSxzQkFBQTtFQUNBLDBCQUFBO0VBQ0EsWUFBQTtFQUNBLGFBQUE7RUFDQSx1QkFBQTtFQUNBLG1CQUFBO0VBQ0Esa0JBQUE7RUFDQSxnQkFBQTtFQUNBLGtCQUFBO0VBQ0Esa0JBQUE7RUFDQSxVQUFBO0VBQ0EsdURBQUE7RUFDQSwrR0FBQTtBQ0NGIiwiZmlsZSI6InNyYy9hcHAvcGFnZXMvYW5ndWxhci1tYXRlcmlhbC9jb21wb25lbnRzL21hdC1kcmFnLWRyb3AvbWF0LWRyYWctZHJvcC5wYWdlLnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuZXhhbXBsZS1jb250YWluZXIge1xyXG4gIHdpZHRoOiA0MDBweDtcclxuICBtYXgtd2lkdGg6IDEwMCU7XHJcbiAgbWFyZ2luOiAwIDI1cHggMjVweCAwO1xyXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xyXG59XHJcblxyXG4uZXhhbXBsZS1saXN0IHtcclxuICBib3JkZXI6IHNvbGlkIDFweCAjY2NjO1xyXG4gIG1pbi1oZWlnaHQ6IDYwcHg7XHJcbiAgYmFja2dyb3VuZDogd2hpdGU7XHJcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xyXG4gIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgZGlzcGxheTogYmxvY2s7XHJcbn1cclxuXHJcbi5leGFtcGxlLWJveCB7XHJcbiAgcGFkZGluZzogMjBweCAxMHB4O1xyXG4gIGJvcmRlci1ib3R0b206IHNvbGlkIDFweCAjY2NjO1xyXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODcpO1xyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcclxuICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcclxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG4gIGN1cnNvcjogbW92ZTtcclxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcclxuICBmb250LXNpemU6IDE0cHg7XHJcbn1cclxuXHJcbi5jZGstZHJhZy1wcmV2aWV3IHtcclxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcclxuICBib3gtc2hhZG93OiAwIDVweCA1cHggLTNweCByZ2JhKDAsIDAsIDAsIDAuMiksIDAgOHB4IDEwcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4xNCksIDAgM3B4IDE0cHggMnB4IHJnYmEoMCwgMCwgMCwgMC4xMik7XHJcbn1cclxuXHJcbi5jZGstZHJhZy1wbGFjZWhvbGRlciB7XHJcbiAgb3BhY2l0eTogMDtcclxufVxyXG5cclxuLmNkay1kcmFnLWFuaW1hdGluZyB7XHJcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDI1MG1zIGN1YmljLWJlemllcigwLCAwLCAwLjIsIDEpO1xyXG59XHJcblxyXG4uZXhhbXBsZS1ib3g6bGFzdC1jaGlsZCB7XHJcbiAgYm9yZGVyOiBub25lO1xyXG59XHJcblxyXG4uZXhhbXBsZS1saXN0LmNkay1kcm9wLWxpc3QtZHJhZ2dpbmcgLmV4YW1wbGUtYm94Om5vdCguY2RrLWRyYWctcGxhY2Vob2xkZXIpIHtcclxuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMjUwbXMgY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMSk7XHJcbn1cclxuXHJcbi5leGFtcGxlLWJveC1iYXNpYzphY3RpdmUge1xyXG4gIGJveC1zaGFkb3c6IDAgNXB4IDVweCAtM3B4IHJnYmEoMCwgMCwgMCwgMC4yKSwgMCA4cHggMTBweCAxcHggcmdiYSgwLCAwLCAwLCAwLjE0KSwgMCAzcHggMTRweCAycHggcmdiYSgwLCAwLCAwLCAwLjEyKTtcclxufVxyXG5cclxuLmV4YW1wbGUtYm94LWJhc2ljIHtcclxuICB3aWR0aDogMjAwcHg7XHJcbiAgaGVpZ2h0OiAyMDBweDtcclxuICBib3JkZXI6IHNvbGlkIDFweCAjY2NjO1xyXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODcpO1xyXG4gIGN1cnNvcjogbW92ZTtcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gIGJhY2tncm91bmQ6ICNmZmY7XHJcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xyXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICB6LWluZGV4OiAxO1xyXG4gIHRyYW5zaXRpb246IGJveC1zaGFkb3cgMjAwbXMgY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMSk7XHJcbiAgYm94LXNoYWRvdzogMCAzcHggMXB4IC0ycHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwIDJweCAycHggMCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDFweCA1cHggMCByZ2JhKDAsIDAsIDAsIDAuMTIpO1xyXG59XHJcbiIsIi5leGFtcGxlLWNvbnRhaW5lciB7XG4gIHdpZHRoOiA0MDBweDtcbiAgbWF4LXdpZHRoOiAxMDAlO1xuICBtYXJnaW46IDAgMjVweCAyNXB4IDA7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgdmVydGljYWwtYWxpZ246IHRvcDtcbn1cblxuLmV4YW1wbGUtbGlzdCB7XG4gIGJvcmRlcjogc29saWQgMXB4ICNjY2M7XG4gIG1pbi1oZWlnaHQ6IDYwcHg7XG4gIGJhY2tncm91bmQ6IHdoaXRlO1xuICBib3JkZXItcmFkaXVzOiA0cHg7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIGRpc3BsYXk6IGJsb2NrO1xufVxuXG4uZXhhbXBsZS1ib3gge1xuICBwYWRkaW5nOiAyMHB4IDEwcHg7XG4gIGJvcmRlci1ib3R0b206IHNvbGlkIDFweCAjY2NjO1xuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjg3KTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBjdXJzb3I6IG1vdmU7XG4gIGJhY2tncm91bmQ6IHdoaXRlO1xuICBmb250LXNpemU6IDE0cHg7XG59XG5cbi5jZGstZHJhZy1wcmV2aWV3IHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xuICBib3gtc2hhZG93OiAwIDVweCA1cHggLTNweCByZ2JhKDAsIDAsIDAsIDAuMiksIDAgOHB4IDEwcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4xNCksIDAgM3B4IDE0cHggMnB4IHJnYmEoMCwgMCwgMCwgMC4xMik7XG59XG5cbi5jZGstZHJhZy1wbGFjZWhvbGRlciB7XG4gIG9wYWNpdHk6IDA7XG59XG5cbi5jZGstZHJhZy1hbmltYXRpbmcge1xuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMjUwbXMgY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMSk7XG59XG5cbi5leGFtcGxlLWJveDpsYXN0LWNoaWxkIHtcbiAgYm9yZGVyOiBub25lO1xufVxuXG4uZXhhbXBsZS1saXN0LmNkay1kcm9wLWxpc3QtZHJhZ2dpbmcgLmV4YW1wbGUtYm94Om5vdCguY2RrLWRyYWctcGxhY2Vob2xkZXIpIHtcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDI1MG1zIGN1YmljLWJlemllcigwLCAwLCAwLjIsIDEpO1xufVxuXG4uZXhhbXBsZS1ib3gtYmFzaWM6YWN0aXZlIHtcbiAgYm94LXNoYWRvdzogMCA1cHggNXB4IC0zcHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwIDhweCAxMHB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDNweCAxNHB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMTIpO1xufVxuXG4uZXhhbXBsZS1ib3gtYmFzaWMge1xuICB3aWR0aDogMjAwcHg7XG4gIGhlaWdodDogMjAwcHg7XG4gIGJvcmRlcjogc29saWQgMXB4ICNjY2M7XG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODcpO1xuICBjdXJzb3I6IG1vdmU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIGJhY2tncm91bmQ6ICNmZmY7XG4gIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB6LWluZGV4OiAxO1xuICB0cmFuc2l0aW9uOiBib3gtc2hhZG93IDIwMG1zIGN1YmljLWJlemllcigwLCAwLCAwLjIsIDEpO1xuICBib3gtc2hhZG93OiAwIDNweCAxcHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMiksIDAgMnB4IDJweCAwIHJnYmEoMCwgMCwgMCwgMC4xNCksIDAgMXB4IDVweCAwIHJnYmEoMCwgMCwgMCwgMC4xMik7XG59Il19 */\");\n\n/***/ }),\n\n/***/ \"./src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.page.ts\":\n/*!***************************************************************************************!*\\\n  !*** ./src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.page.ts ***!\n  \\***************************************************************************************/\n/*! exports provided: MatDragDropPage */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MatDragDropPage\", function() { return MatDragDropPage; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm2015/core.js\");\n/* harmony import */ var _angular_cdk_drag_drop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/drag-drop */ \"./node_modules/@angular/cdk/esm2015/drag-drop.js\");\n\n\n\nlet MatDragDropPage = class MatDragDropPage {\n    constructor() {\n        this.todo = [\n            'Get to work',\n            'Pick up groceries',\n            'Go home',\n            'Fall asleep'\n        ];\n        this.done = [\n            'Get up',\n            'Brush teeth',\n            'Take a shower',\n            'Check e-mail',\n            'Walk dog'\n        ];\n    }\n    ngOnInit() {\n    }\n    drop(event) {\n        if (event.previousContainer === event.container) {\n            Object(_angular_cdk_drag_drop__WEBPACK_IMPORTED_MODULE_2__[\"moveItemInArray\"])(event.container.data, event.previousIndex, event.currentIndex);\n        }\n        else {\n            Object(_angular_cdk_drag_drop__WEBPACK_IMPORTED_MODULE_2__[\"transferArrayItem\"])(event.previousContainer.data, event.container.data, event.previousIndex, event.currentIndex);\n        }\n    }\n};\nMatDragDropPage = tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([\n    Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Component\"])({\n        selector: 'app-mat-drag-drop',\n        template: tslib__WEBPACK_IMPORTED_MODULE_0__[\"__importDefault\"](__webpack_require__(/*! raw-loader!./mat-drag-drop.page.html */ \"./node_modules/raw-loader/dist/cjs.js!./src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.page.html\")).default,\n        styles: [tslib__WEBPACK_IMPORTED_MODULE_0__[\"__importDefault\"](__webpack_require__(/*! ./mat-drag-drop.page.scss */ \"./src/app/pages/angular-material/components/mat-drag-drop/mat-drag-drop.page.scss\")).default]\n    }),\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__metadata\"](\"design:paramtypes\", [])\n], MatDragDropPage);\n\n\n\n/***/ })\n\n}]);\n//# sourceMappingURL=pages-angular-material-components-mat-drag-drop-mat-drag-drop-module-es2015.js.map","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { DOCUMENT } from '@angular/common';\nimport { inject, InjectionToken, EventEmitter, Inject, Injectable, Optional, Directive, Output, Input, NgModule, defineInjectable, inject } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n *\n * This token is defined in a separate file from Directionality as a workaround for\n * https://github.com/angular/angular/issues/22559\n *\n * \\@docs-private\n * @type {?}\n */\nconst DIR_DOCUMENT = new InjectionToken('cdk-dir-doc', {\n    providedIn: 'root',\n    factory: DIR_DOCUMENT_FACTORY,\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction DIR_DOCUMENT_FACTORY() {\n    return inject(DOCUMENT);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nclass Directionality {\n    /**\n     * @param {?=} _document\n     */\n    constructor(_document) {\n        /**\n         * The current 'ltr' or 'rtl' value.\n         */\n        this.value = 'ltr';\n        /**\n         * Stream that emits whenever the 'ltr' / 'rtl' state changes.\n         */\n        this.change = new EventEmitter();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            /** @type {?} */\n            const bodyDir = _document.body ? _document.body.dir : null;\n            /** @type {?} */\n            const htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            /** @type {?} */\n            const value = bodyDir || htmlDir;\n            this.value = (value === 'ltr' || value === 'rtl') ? value : 'ltr';\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.change.complete();\n    }\n}\nDirectionality.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nDirectionality.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DIR_DOCUMENT,] }] }\n];\n/** @nocollapse */ Directionality.ngInjectableDef = defineInjectable({ factory: function Directionality_Factory() { return new Directionality(inject(DIR_DOCUMENT, 8)); }, token: Directionality, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nclass Dir {\n    constructor() {\n        /**\n         * Normalized direction that accounts for invalid/unsupported values.\n         */\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new EventEmitter();\n    }\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    get dir() { return this._dir; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set dir(value) {\n        /** @type {?} */\n        const old = this._dir;\n        /** @type {?} */\n        const normalizedValue = value ? value.toLowerCase() : value;\n        this._rawDir = value;\n        this._dir = (normalizedValue === 'ltr' || normalizedValue === 'rtl') ? normalizedValue : 'ltr';\n        if (old !== this._dir && this._isInitialized) {\n            this.change.emit(this._dir);\n        }\n    }\n    /**\n     * Current layout direction of the element.\n     * @return {?}\n     */\n    get value() { return this.dir; }\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._isInitialized = true;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.change.complete();\n    }\n}\nDir.decorators = [\n    { type: Directive, args: [{\n                selector: '[dir]',\n                providers: [{ provide: Directionality, useExisting: Dir }],\n                host: { '[attr.dir]': '_rawDir' },\n                exportAs: 'dir',\n            },] },\n];\nDir.propDecorators = {\n    change: [{ type: Output, args: ['dirChange',] }],\n    dir: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass BidiModule {\n}\nBidiModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [Dir],\n                declarations: [Dir],\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { Directionality, DIR_DOCUMENT, Dir, BidiModule, DIR_DOCUMENT_FACTORY as a };\n//# sourceMappingURL=bidi.js.map\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { normalizePassiveListenerOptions, _supportsShadowDom } from '@angular/cdk/platform';\nimport { coerceBooleanProperty, coerceElement, coerceNumberProperty, coerceArray } from '@angular/cdk/coercion';\nimport { Subscription, Subject, interval, animationFrameScheduler, Observable, merge } from 'rxjs';\nimport { startWith, takeUntil, take, map, switchMap, tap } from 'rxjs/operators';\nimport { Injectable, NgZone, Inject, InjectionToken, NgModule, ContentChildren, ElementRef, EventEmitter, forwardRef, Input, Output, Optional, Directive, ChangeDetectorRef, SkipSelf, ContentChild, ViewContainerRef, isDevMode, TemplateRef, defineInjectable, inject } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { Directionality } from '@angular/cdk/bidi';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Shallow-extends a stylesheet object with another stylesheet object.\n * \\@docs-private\n * @param {?} dest\n * @param {?} source\n * @return {?}\n */\nfunction extendStyles(dest, source) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            dest[key] = (/** @type {?} */ (source[key]));\n        }\n    }\n    return dest;\n}\n/**\n * Toggles whether the native drag interactions should be enabled for an element.\n * \\@docs-private\n * @param {?} element Element on which to toggle the drag interactions.\n * @param {?} enable Whether the drag interactions should be enabled.\n * @return {?}\n */\nfunction toggleNativeDragInteractions(element, enable) {\n    /** @type {?} */\n    const userSelect = enable ? '' : 'none';\n    extendStyles(element.style, {\n        touchAction: enable ? '' : 'none',\n        webkitUserDrag: enable ? '' : 'none',\n        webkitTapHighlightColor: enable ? '' : 'transparent',\n        userSelect: userSelect,\n        msUserSelect: userSelect,\n        webkitUserSelect: userSelect,\n        MozUserSelect: userSelect\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Parses a CSS time value to milliseconds.\n * @param {?} value\n * @return {?}\n */\nfunction parseCssTimeUnitsToMs(value) {\n    // Some browsers will return it in seconds, whereas others will return milliseconds.\n    /** @type {?} */\n    const multiplier = value.toLowerCase().indexOf('ms') > -1 ? 1 : 1000;\n    return parseFloat(value) * multiplier;\n}\n/**\n * Gets the transform transition duration, including the delay, of an element in milliseconds.\n * @param {?} element\n * @return {?}\n */\nfunction getTransformTransitionDurationInMs(element) {\n    /** @type {?} */\n    const computedStyle = getComputedStyle(element);\n    /** @type {?} */\n    const transitionedProperties = parseCssPropertyValue(computedStyle, 'transition-property');\n    /** @type {?} */\n    const property = transitionedProperties.find((/**\n     * @param {?} prop\n     * @return {?}\n     */\n    prop => prop === 'transform' || prop === 'all'));\n    // If there's no transition for `all` or `transform`, we shouldn't do anything.\n    if (!property) {\n        return 0;\n    }\n    // Get the index of the property that we're interested in and match\n    // it up to the same index in `transition-delay` and `transition-duration`.\n    /** @type {?} */\n    const propertyIndex = transitionedProperties.indexOf(property);\n    /** @type {?} */\n    const rawDurations = parseCssPropertyValue(computedStyle, 'transition-duration');\n    /** @type {?} */\n    const rawDelays = parseCssPropertyValue(computedStyle, 'transition-delay');\n    return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) +\n        parseCssTimeUnitsToMs(rawDelays[propertyIndex]);\n}\n/**\n * Parses out multiple values from a computed style into an array.\n * @param {?} computedStyle\n * @param {?} name\n * @return {?}\n */\nfunction parseCssPropertyValue(computedStyle, name) {\n    /** @type {?} */\n    const value = computedStyle.getPropertyValue(name);\n    return value.split(',').map((/**\n     * @param {?} part\n     * @return {?}\n     */\n    part => part.trim()));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Options that can be used to bind a passive event listener.\n * @type {?}\n */\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });\n/**\n * Options that can be used to bind an active event listener.\n * @type {?}\n */\nconst activeEventListenerOptions = normalizePassiveListenerOptions({ passive: false });\n/**\n * Time in milliseconds for which to ignore mouse events, after\n * receiving a touch event. Used to avoid doing double work for\n * touch devices where the browser fires fake mouse events, in\n * addition to touch events.\n * @type {?}\n */\nconst MOUSE_EVENT_IGNORE_TIME = 800;\n/**\n * Reference to a draggable item. Used to manipulate or dispose of the item.\n * \\@docs-private\n * @template T\n */\nclass DragRef {\n    /**\n     * @param {?} element\n     * @param {?} _config\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewportRuler\n     * @param {?} _dragDropRegistry\n     */\n    constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._config = _config;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n        /**\n         * CSS `transform` applied to the element when it isn't being dragged. We need a\n         * passive transform in order for the dragged element to retain its new position\n         * after the user has stopped dragging and because we need to know the relative\n         * position in case they start dragging again. This corresponds to `element.style.transform`.\n         */\n        this._passiveTransform = { x: 0, y: 0 };\n        /**\n         * CSS `transform` that is applied to the element while it's being dragged.\n         */\n        this._activeTransform = { x: 0, y: 0 };\n        /**\n         * Emits when the item is being moved.\n         */\n        this._moveEvents = new Subject();\n        /**\n         * Subscription to pointer movement events.\n         */\n        this._pointerMoveSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to the event that is dispatched when the user lifts their pointer.\n         */\n        this._pointerUpSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to the viewport being scrolled.\n         */\n        this._scrollSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to the viewport being resized.\n         */\n        this._resizeSubscription = Subscription.EMPTY;\n        /**\n         * Cached reference to the boundary element.\n         */\n        this._boundaryElement = null;\n        /**\n         * Whether the native dragging interactions have been enabled on the root element.\n         */\n        this._nativeInteractionsEnabled = true;\n        /**\n         * Elements that can be used to drag the draggable item.\n         */\n        this._handles = [];\n        /**\n         * Registered handles that are currently disabled.\n         */\n        this._disabledHandles = new Set();\n        /**\n         * Layout direction of the item.\n         */\n        this._direction = 'ltr';\n        /**\n         * Amount of milliseconds to wait after the user has put their\n         * pointer down before starting to drag the element.\n         */\n        this.dragStartDelay = 0;\n        this._disabled = false;\n        /**\n         * Emits as the drag sequence is being prepared.\n         */\n        this.beforeStarted = new Subject();\n        /**\n         * Emits when the user starts dragging the item.\n         */\n        this.started = new Subject();\n        /**\n         * Emits when the user has released a drag item, before any animations have started.\n         */\n        this.released = new Subject();\n        /**\n         * Emits when the user stops dragging an item in the container.\n         */\n        this.ended = new Subject();\n        /**\n         * Emits when the user has moved the item into a new container.\n         */\n        this.entered = new Subject();\n        /**\n         * Emits when the user removes the item its container by dragging it into another container.\n         */\n        this.exited = new Subject();\n        /**\n         * Emits when the user drops the item inside a container.\n         */\n        this.dropped = new Subject();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = this._moveEvents.asObservable();\n        /**\n         * Handler for the `mousedown`/`touchstart` events.\n         */\n        this._pointerDown = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            this.beforeStarted.next();\n            // Delegate the event based on whether it started from a handle or the element itself.\n            if (this._handles.length) {\n                /** @type {?} */\n                const targetHandle = this._handles.find((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => {\n                    /** @type {?} */\n                    const target = event.target;\n                    return !!target && (target === handle || handle.contains((/** @type {?} */ (target))));\n                }));\n                if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {\n                    this._initializeDragSequence(targetHandle, event);\n                }\n            }\n            else if (!this.disabled) {\n                this._initializeDragSequence(this._rootElement, event);\n            }\n        });\n        /**\n         * Handler that is invoked when the user moves their pointer after they've initiated a drag.\n         */\n        this._pointerMove = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            if (!this._hasStartedDragging) {\n                /** @type {?} */\n                const pointerPosition = this._getPointerPositionOnPage(event);\n                /** @type {?} */\n                const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);\n                /** @type {?} */\n                const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);\n                /** @type {?} */\n                const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;\n                // Only start dragging after the user has moved more than the minimum distance in either\n                // direction. Note that this is preferrable over doing something like `skip(minimumDistance)`\n                // in the `pointerMove` subscription, because we're not guaranteed to have one move event\n                // per pixel of movement (e.g. if the user moves their pointer quickly).\n                if (isOverThreshold) {\n                    /** @type {?} */\n                    const isDelayElapsed = Date.now() >= this._dragStartTime + (this.dragStartDelay || 0);\n                    if (!isDelayElapsed) {\n                        this._endDragSequence(event);\n                        return;\n                    }\n                    // Prevent other drag sequences from starting while something in the container is still\n                    // being dragged. This can happen while we're waiting for the drop animation to finish\n                    // and can cause errors, because some elements might still be moving around.\n                    if (!this._dropContainer || !this._dropContainer.isDragging()) {\n                        this._hasStartedDragging = true;\n                        this._ngZone.run((/**\n                         * @return {?}\n                         */\n                        () => this._startDragSequence(event)));\n                    }\n                }\n                return;\n            }\n            // We only need the preview dimensions if we have a boundary element.\n            if (this._boundaryElement) {\n                // Cache the preview element rect if we haven't cached it already or if\n                // we cached it too early before the element dimensions were computed.\n                if (!this._previewRect || (!this._previewRect.width && !this._previewRect.height)) {\n                    this._previewRect = (this._preview || this._rootElement).getBoundingClientRect();\n                }\n            }\n            /** @type {?} */\n            const constrainedPointerPosition = this._getConstrainedPointerPosition(event);\n            this._hasMoved = true;\n            event.preventDefault();\n            this._updatePointerDirectionDelta(constrainedPointerPosition);\n            if (this._dropContainer) {\n                this._updateActiveDropContainer(constrainedPointerPosition);\n            }\n            else {\n                /** @type {?} */\n                const activeTransform = this._activeTransform;\n                activeTransform.x =\n                    constrainedPointerPosition.x - this._pickupPositionOnPage.x + this._passiveTransform.x;\n                activeTransform.y =\n                    constrainedPointerPosition.y - this._pickupPositionOnPage.y + this._passiveTransform.y;\n                this._applyRootElementTransform(activeTransform.x, activeTransform.y);\n                // Apply transform as attribute if dragging and svg element to work for IE\n                if (typeof SVGElement !== 'undefined' && this._rootElement instanceof SVGElement) {\n                    /** @type {?} */\n                    const appliedTransform = `translate(${activeTransform.x} ${activeTransform.y})`;\n                    this._rootElement.setAttribute('transform', appliedTransform);\n                }\n            }\n            // Since this event gets fired for every pixel while dragging, we only\n            // want to fire it if the consumer opted into it. Also we have to\n            // re-enter the zone because we run all of the events on the outside.\n            if (this._moveEvents.observers.length) {\n                this._ngZone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this._moveEvents.next({\n                        source: this,\n                        pointerPosition: constrainedPointerPosition,\n                        event,\n                        distance: this._getDragDistance(constrainedPointerPosition),\n                        delta: this._pointerDirectionDelta\n                    });\n                }));\n            }\n        });\n        /**\n         * Handler that is invoked when the user lifts their pointer up, after initiating a drag.\n         */\n        this._pointerUp = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            this._endDragSequence(event);\n        });\n        this.withRootElement(element);\n        _dragDropRegistry.registerDragItem(this);\n    }\n    /**\n     * Whether starting to drag this element is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        /** @type {?} */\n        const newValue = coerceBooleanProperty(value);\n        if (newValue !== this._disabled) {\n            this._disabled = newValue;\n            this._toggleNativeDragInteractions();\n        }\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    getPlaceholderElement() {\n        return this._placeholder;\n    }\n    /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    getRootElement() {\n        return this._rootElement;\n    }\n    /**\n     * Registers the handles that can be used to drag the element.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} handles\n     * @return {THIS}\n     */\n    withHandles(handles) {\n        (/** @type {?} */ (this))._handles = handles.map((/**\n         * @param {?} handle\n         * @return {?}\n         */\n        handle => coerceElement(handle)));\n        (/** @type {?} */ (this))._handles.forEach((/**\n         * @param {?} handle\n         * @return {?}\n         */\n        handle => toggleNativeDragInteractions(handle, false)));\n        (/** @type {?} */ (this))._toggleNativeDragInteractions();\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Registers the template that should be used for the drag preview.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the preview.\n     * @return {THIS}\n     */\n    withPreviewTemplate(template) {\n        (/** @type {?} */ (this))._previewTemplate = template;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Registers the template that should be used for the drag placeholder.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the placeholder.\n     * @return {THIS}\n     */\n    withPlaceholderTemplate(template) {\n        (/** @type {?} */ (this))._placeholderTemplate = template;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets an alternate drag root element. The root element is the element that will be moved as\n     * the user is dragging. Passing an alternate root element is useful when trying to enable\n     * dragging on an element that you might not have access to.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} rootElement\n     * @return {THIS}\n     */\n    withRootElement(rootElement) {\n        /** @type {?} */\n        const element = coerceElement(rootElement);\n        if (element !== (/** @type {?} */ (this))._rootElement) {\n            if ((/** @type {?} */ (this))._rootElement) {\n                (/** @type {?} */ (this))._removeRootElementListeners((/** @type {?} */ (this))._rootElement);\n            }\n            element.addEventListener('mousedown', (/** @type {?} */ (this))._pointerDown, activeEventListenerOptions);\n            element.addEventListener('touchstart', (/** @type {?} */ (this))._pointerDown, passiveEventListenerOptions);\n            (/** @type {?} */ (this))._initialTransform = undefined;\n            (/** @type {?} */ (this))._rootElement = element;\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Element to which the draggable's position will be constrained.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} boundaryElement\n     * @return {THIS}\n     */\n    withBoundaryElement(boundaryElement) {\n        (/** @type {?} */ (this))._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;\n        (/** @type {?} */ (this))._resizeSubscription.unsubscribe();\n        if (boundaryElement) {\n            (/** @type {?} */ (this))._resizeSubscription = (/** @type {?} */ (this))._viewportRuler\n                .change(10)\n                .subscribe((/**\n             * @return {?}\n             */\n            () => (/** @type {?} */ (this))._containInsideBoundaryOnResize()));\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Removes the dragging functionality from the DOM element.\n     * @return {?}\n     */\n    dispose() {\n        this._removeRootElementListeners(this._rootElement);\n        // Do this check before removing from the registry since it'll\n        // stop being considered as dragged once it is removed.\n        if (this.isDragging()) {\n            // Since we move out the element to the end of the body while it's being\n            // dragged, we have to make sure that it's removed if it gets destroyed.\n            removeElement(this._rootElement);\n        }\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._dragDropRegistry.removeDragItem(this);\n        this._removeSubscriptions();\n        this.beforeStarted.complete();\n        this.started.complete();\n        this.released.complete();\n        this.ended.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this._moveEvents.complete();\n        this._handles = [];\n        this._disabledHandles.clear();\n        this._dropContainer = undefined;\n        this._boundaryElement = this._rootElement = this._placeholderTemplate =\n            this._previewTemplate = this._nextSibling = (/** @type {?} */ (null));\n    }\n    /**\n     * Checks whether the element is currently being dragged.\n     * @return {?}\n     */\n    isDragging() {\n        return this._hasStartedDragging && this._dragDropRegistry.isDragging(this);\n    }\n    /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    reset() {\n        this._rootElement.style.transform = this._initialTransform || '';\n        this._activeTransform = { x: 0, y: 0 };\n        this._passiveTransform = { x: 0, y: 0 };\n    }\n    /**\n     * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.\n     * @param {?} handle Handle element that should be disabled.\n     * @return {?}\n     */\n    disableHandle(handle) {\n        if (this._handles.indexOf(handle) > -1) {\n            this._disabledHandles.add(handle);\n        }\n    }\n    /**\n     * Enables a handle, if it has been disabled.\n     * @param {?} handle Handle element to be enabled.\n     * @return {?}\n     */\n    enableHandle(handle) {\n        this._disabledHandles.delete(handle);\n    }\n    /**\n     * Sets the layout direction of the draggable item.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    withDirection(direction) {\n        (/** @type {?} */ (this))._direction = direction;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the container that the item is part of.\n     * @param {?} container\n     * @return {?}\n     */\n    _withDropContainer(container) {\n        this._dropContainer = container;\n    }\n    /**\n     * Gets the current position in pixels the draggable outside of a drop container.\n     * @return {?}\n     */\n    getFreeDragPosition() {\n        /** @type {?} */\n        const position = this.isDragging() ? this._activeTransform : this._passiveTransform;\n        return { x: position.x, y: position.y };\n    }\n    /**\n     * Sets the current position in pixels the draggable outside of a drop container.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} value New position to be set.\n     * @return {THIS}\n     */\n    setFreeDragPosition(value) {\n        (/** @type {?} */ (this))._activeTransform = { x: 0, y: 0 };\n        (/** @type {?} */ (this))._passiveTransform.x = value.x;\n        (/** @type {?} */ (this))._passiveTransform.y = value.y;\n        if (!(/** @type {?} */ (this))._dropContainer) {\n            (/** @type {?} */ (this))._applyRootElementTransform(value.x, value.y);\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Updates the item's sort order based on the last-known pointer position.\n     * @return {?}\n     */\n    _sortFromLastPointerPosition() {\n        /** @type {?} */\n        const position = this._pointerPositionAtLastDirectionChange;\n        if (position && this._dropContainer) {\n            this._updateActiveDropContainer(position);\n        }\n    }\n    /**\n     * Unsubscribes from the global subscriptions.\n     * @private\n     * @return {?}\n     */\n    _removeSubscriptions() {\n        this._pointerMoveSubscription.unsubscribe();\n        this._pointerUpSubscription.unsubscribe();\n        this._scrollSubscription.unsubscribe();\n    }\n    /**\n     * Destroys the preview element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    _destroyPreview() {\n        if (this._preview) {\n            removeElement(this._preview);\n        }\n        if (this._previewRef) {\n            this._previewRef.destroy();\n        }\n        this._preview = this._previewRef = (/** @type {?} */ (null));\n    }\n    /**\n     * Destroys the placeholder element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    _destroyPlaceholder() {\n        if (this._placeholder) {\n            removeElement(this._placeholder);\n        }\n        if (this._placeholderRef) {\n            this._placeholderRef.destroy();\n        }\n        this._placeholder = this._placeholderRef = (/** @type {?} */ (null));\n    }\n    /**\n     * Clears subscriptions and stops the dragging sequence.\n     * @private\n     * @param {?} event Browser event object that ended the sequence.\n     * @return {?}\n     */\n    _endDragSequence(event) {\n        // Note that here we use `isDragging` from the service, rather than from `this`.\n        // The difference is that the one from the service reflects whether a dragging sequence\n        // has been initiated, whereas the one on `this` includes whether the user has passed\n        // the minimum dragging threshold.\n        if (!this._dragDropRegistry.isDragging(this)) {\n            return;\n        }\n        this._removeSubscriptions();\n        this._dragDropRegistry.stopDragging(this);\n        this._toggleNativeDragInteractions();\n        if (this._handles) {\n            this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;\n        }\n        if (!this._hasStartedDragging) {\n            return;\n        }\n        this.released.next({ source: this });\n        if (this._dropContainer) {\n            // Stop scrolling immediately, instead of waiting for the animation to finish.\n            this._dropContainer._stopScrolling();\n            this._animatePreviewToPlaceholder().then((/**\n             * @return {?}\n             */\n            () => {\n                this._cleanupDragArtifacts(event);\n                this._cleanupCachedDimensions();\n                this._dragDropRegistry.stopDragging(this);\n            }));\n        }\n        else {\n            // Convert the active transform into a passive one. This means that next time\n            // the user starts dragging the item, its position will be calculated relatively\n            // to the new passive transform.\n            this._passiveTransform.x = this._activeTransform.x;\n            this._passiveTransform.y = this._activeTransform.y;\n            this._ngZone.run((/**\n             * @return {?}\n             */\n            () => {\n                this.ended.next({\n                    source: this,\n                    distance: this._getDragDistance(this._getPointerPositionOnPage(event))\n                });\n            }));\n            this._cleanupCachedDimensions();\n            this._dragDropRegistry.stopDragging(this);\n        }\n    }\n    /**\n     * Starts the dragging sequence.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _startDragSequence(event) {\n        // Emit the event on the item before the one on the container.\n        this.started.next({ source: this });\n        if (isTouchEvent(event)) {\n            this._lastTouchEventTime = Date.now();\n        }\n        this._toggleNativeDragInteractions();\n        if (this._dropContainer) {\n            /** @type {?} */\n            const element = this._rootElement;\n            // Grab the `nextSibling` before the preview and placeholder\n            // have been created so we don't get the preview by accident.\n            this._nextSibling = element.nextSibling;\n            /** @type {?} */\n            const preview = this._preview = this._createPreviewElement();\n            /** @type {?} */\n            const placeholder = this._placeholder = this._createPlaceholderElement();\n            // We move the element out at the end of the body and we make it hidden, because keeping it in\n            // place will throw off the consumer's `:last-child` selectors. We can't remove the element\n            // from the DOM completely, because iOS will stop firing all subsequent events in the chain.\n            element.style.display = 'none';\n            this._document.body.appendChild((/** @type {?} */ (element.parentNode)).replaceChild(placeholder, element));\n            getPreviewInsertionPoint(this._document).appendChild(preview);\n            this._dropContainer.start();\n        }\n    }\n    /**\n     * Sets up the different variables and subscriptions\n     * that will be necessary for the dragging sequence.\n     * @private\n     * @param {?} referenceElement Element that started the drag sequence.\n     * @param {?} event Browser event object that started the sequence.\n     * @return {?}\n     */\n    _initializeDragSequence(referenceElement, event) {\n        // Always stop propagation for the event that initializes\n        // the dragging sequence, in order to prevent it from potentially\n        // starting another sequence for a draggable parent somewhere up the DOM tree.\n        event.stopPropagation();\n        /** @type {?} */\n        const isDragging = this.isDragging();\n        /** @type {?} */\n        const isTouchSequence = isTouchEvent(event);\n        /** @type {?} */\n        const isAuxiliaryMouseButton = !isTouchSequence && ((/** @type {?} */ (event))).button !== 0;\n        /** @type {?} */\n        const rootElement = this._rootElement;\n        /** @type {?} */\n        const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime &&\n            this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();\n        // If the event started from an element with the native HTML drag&drop, it'll interfere\n        // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n        // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n        // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n        // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n        // events from firing on touch devices.\n        if (event.target && ((/** @type {?} */ (event.target))).draggable && event.type === 'mousedown') {\n            event.preventDefault();\n        }\n        // Abort if the user is already dragging or is using a mouse button other than the primary one.\n        if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent) {\n            return;\n        }\n        // If we've got handles, we need to disable the tap highlight on the entire root element,\n        // otherwise iOS will still add it, even though all the drag interactions on the handle\n        // are disabled.\n        if (this._handles.length) {\n            this._rootElementTapHighlight = rootElement.style.webkitTapHighlightColor;\n            rootElement.style.webkitTapHighlightColor = 'transparent';\n        }\n        this._hasStartedDragging = this._hasMoved = false;\n        this._initialContainer = (/** @type {?} */ (this._dropContainer));\n        // Avoid multiple subscriptions and memory leaks when multi touch\n        // (isDragging check above isn't enough because of possible temporal and/or dimensional delays)\n        this._removeSubscriptions();\n        this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);\n        this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);\n        this._scrollSubscription = this._dragDropRegistry.scroll.pipe(startWith(null)).subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._scrollPosition = this._viewportRuler.getViewportScrollPosition();\n        }));\n        if (this._boundaryElement) {\n            this._boundaryRect = this._boundaryElement.getBoundingClientRect();\n        }\n        // If we have a custom preview template, the element won't be visible anyway so we avoid the\n        // extra `getBoundingClientRect` calls and just move the preview next to the cursor.\n        this._pickupPositionInElement = this._previewTemplate && this._previewTemplate.template ?\n            { x: 0, y: 0 } :\n            this._getPointerPositionInElement(referenceElement, event);\n        /** @type {?} */\n        const pointerPosition = this._pickupPositionOnPage = this._getPointerPositionOnPage(event);\n        this._pointerDirectionDelta = { x: 0, y: 0 };\n        this._pointerPositionAtLastDirectionChange = { x: pointerPosition.x, y: pointerPosition.y };\n        this._dragStartTime = Date.now();\n        this._dragDropRegistry.startDragging(this, event);\n    }\n    /**\n     * Cleans up the DOM artifacts that were added to facilitate the element being dragged.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _cleanupDragArtifacts(event) {\n        // Restore the element's visibility and insert it at its old position in the DOM.\n        // It's important that we maintain the position, because moving the element around in the DOM\n        // can throw off `NgFor` which does smart diffing and re-creates elements only when necessary,\n        // while moving the existing elements in all other cases.\n        this._rootElement.style.display = '';\n        if (this._nextSibling) {\n            (/** @type {?} */ (this._nextSibling.parentNode)).insertBefore(this._rootElement, this._nextSibling);\n        }\n        else {\n            coerceElement(this._initialContainer.element).appendChild(this._rootElement);\n        }\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._boundaryRect = this._previewRect = undefined;\n        // Re-enter the NgZone since we bound `document` events on the outside.\n        this._ngZone.run((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const container = (/** @type {?} */ (this._dropContainer));\n            /** @type {?} */\n            const currentIndex = container.getItemIndex(this);\n            /** @type {?} */\n            const pointerPosition = this._getPointerPositionOnPage(event);\n            /** @type {?} */\n            const distance = this._getDragDistance(this._getPointerPositionOnPage(event));\n            /** @type {?} */\n            const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);\n            this.ended.next({ source: this, distance });\n            this.dropped.next({\n                item: this,\n                currentIndex,\n                previousIndex: this._initialContainer.getItemIndex(this),\n                container: container,\n                previousContainer: this._initialContainer,\n                isPointerOverContainer,\n                distance\n            });\n            container.drop(this, currentIndex, this._initialContainer, isPointerOverContainer, distance);\n            this._dropContainer = this._initialContainer;\n        }));\n    }\n    /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     * @private\n     * @param {?} __0\n     * @return {?}\n     */\n    _updateActiveDropContainer({ x, y }) {\n        // Drop container that draggable has been moved into.\n        /** @type {?} */\n        let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);\n        // If we couldn't find a new container to move the item into, and the item has left its\n        // initial container, check whether the it's over the initial container. This handles the\n        // case where two containers are connected one way and the user tries to undo dragging an\n        // item into a new container.\n        if (!newContainer && this._dropContainer !== this._initialContainer &&\n            this._initialContainer._isOverContainer(x, y)) {\n            newContainer = this._initialContainer;\n        }\n        if (newContainer && newContainer !== this._dropContainer) {\n            this._ngZone.run((/**\n             * @return {?}\n             */\n            () => {\n                // Notify the old container that the item has left.\n                this.exited.next({ item: this, container: (/** @type {?} */ (this._dropContainer)) });\n                (/** @type {?} */ (this._dropContainer)).exit(this);\n                // Notify the new container that the item has entered.\n                this._dropContainer = (/** @type {?} */ (newContainer));\n                this._dropContainer.enter(this, x, y);\n                this.entered.next({\n                    item: this,\n                    container: (/** @type {?} */ (newContainer)),\n                    currentIndex: (/** @type {?} */ (newContainer)).getItemIndex(this)\n                });\n            }));\n        }\n        (/** @type {?} */ (this._dropContainer))._startScrollingIfNecessary(x, y);\n        (/** @type {?} */ (this._dropContainer))._sortItem(this, x, y, this._pointerDirectionDelta);\n        this._preview.style.transform =\n            getTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);\n    }\n    /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     * @private\n     * @return {?}\n     */\n    _createPreviewElement() {\n        /** @type {?} */\n        const previewConfig = this._previewTemplate;\n        /** @type {?} */\n        const previewTemplate = previewConfig ? previewConfig.template : null;\n        /** @type {?} */\n        let preview;\n        if (previewTemplate) {\n            /** @type {?} */\n            const viewRef = (/** @type {?} */ (previewConfig)).viewContainer.createEmbeddedView(previewTemplate, (/** @type {?} */ (previewConfig)).context);\n            preview = getRootNode(viewRef, this._document);\n            this._previewRef = viewRef;\n            preview.style.transform =\n                getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);\n        }\n        else {\n            /** @type {?} */\n            const element = this._rootElement;\n            /** @type {?} */\n            const elementRect = element.getBoundingClientRect();\n            preview = deepCloneNode(element);\n            preview.style.width = `${elementRect.width}px`;\n            preview.style.height = `${elementRect.height}px`;\n            preview.style.transform = getTransform(elementRect.left, elementRect.top);\n        }\n        extendStyles(preview.style, {\n            // It's important that we disable the pointer events on the preview, because\n            // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.\n            pointerEvents: 'none',\n            // We have to reset the margin, because can throw off positioning relative to the viewport.\n            margin: '0',\n            position: 'fixed',\n            top: '0',\n            left: '0',\n            zIndex: '1000'\n        });\n        toggleNativeDragInteractions(preview, false);\n        preview.classList.add('cdk-drag-preview');\n        preview.setAttribute('dir', this._direction);\n        return preview;\n    }\n    /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @private\n     * @return {?} Promise that resolves when the animation completes.\n     */\n    _animatePreviewToPlaceholder() {\n        // If the user hasn't moved yet, the transitionend event won't fire.\n        if (!this._hasMoved) {\n            return Promise.resolve();\n        }\n        /** @type {?} */\n        const placeholderRect = this._placeholder.getBoundingClientRect();\n        // Apply the class that adds a transition to the preview.\n        this._preview.classList.add('cdk-drag-animating');\n        // Move the preview to the placeholder position.\n        this._preview.style.transform = getTransform(placeholderRect.left, placeholderRect.top);\n        // If the element doesn't have a `transition`, the `transitionend` event won't fire. Since\n        // we need to trigger a style recalculation in order for the `cdk-drag-animating` class to\n        // apply its style, we take advantage of the available info to figure out whether we need to\n        // bind the event in the first place.\n        /** @type {?} */\n        const duration = getTransformTransitionDurationInMs(this._preview);\n        if (duration === 0) {\n            return Promise.resolve();\n        }\n        return this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            return new Promise((/**\n             * @param {?} resolve\n             * @return {?}\n             */\n            resolve => {\n                /** @type {?} */\n                const handler = (/** @type {?} */ (((/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                (event) => {\n                    if (!event || (event.target === this._preview && event.propertyName === 'transform')) {\n                        this._preview.removeEventListener('transitionend', handler);\n                        resolve();\n                        clearTimeout(timeout);\n                    }\n                }))));\n                // If a transition is short enough, the browser might not fire the `transitionend` event.\n                // Since we know how long it's supposed to take, add a timeout with a 50% buffer that'll\n                // fire if the transition hasn't completed when it was supposed to.\n                /** @type {?} */\n                const timeout = setTimeout((/** @type {?} */ (handler)), duration * 1.5);\n                this._preview.addEventListener('transitionend', handler);\n            }));\n        }));\n    }\n    /**\n     * Creates an element that will be shown instead of the current element while dragging.\n     * @private\n     * @return {?}\n     */\n    _createPlaceholderElement() {\n        /** @type {?} */\n        const placeholderConfig = this._placeholderTemplate;\n        /** @type {?} */\n        const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;\n        /** @type {?} */\n        let placeholder;\n        if (placeholderTemplate) {\n            this._placeholderRef = (/** @type {?} */ (placeholderConfig)).viewContainer.createEmbeddedView(placeholderTemplate, (/** @type {?} */ (placeholderConfig)).context);\n            placeholder = getRootNode(this._placeholderRef, this._document);\n        }\n        else {\n            placeholder = deepCloneNode(this._rootElement);\n        }\n        placeholder.classList.add('cdk-drag-placeholder');\n        return placeholder;\n    }\n    /**\n     * Figures out the coordinates at which an element was picked up.\n     * @private\n     * @param {?} referenceElement Element that initiated the dragging.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    _getPointerPositionInElement(referenceElement, event) {\n        /** @type {?} */\n        const elementRect = this._rootElement.getBoundingClientRect();\n        /** @type {?} */\n        const handleElement = referenceElement === this._rootElement ? null : referenceElement;\n        /** @type {?} */\n        const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;\n        /** @type {?} */\n        const point = isTouchEvent(event) ? event.targetTouches[0] : event;\n        /** @type {?} */\n        const x = point.pageX - referenceRect.left - this._scrollPosition.left;\n        /** @type {?} */\n        const y = point.pageY - referenceRect.top - this._scrollPosition.top;\n        return {\n            x: referenceRect.left - elementRect.left + x,\n            y: referenceRect.top - elementRect.top + y\n        };\n    }\n    /**\n     * Determines the point of the page that was touched by the user.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _getPointerPositionOnPage(event) {\n        // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\n        /** @type {?} */\n        const point = isTouchEvent(event) ? (event.touches[0] || event.changedTouches[0]) : event;\n        return {\n            x: point.pageX - this._scrollPosition.left,\n            y: point.pageY - this._scrollPosition.top\n        };\n    }\n    /**\n     * Gets the pointer position on the page, accounting for any position constraints.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _getConstrainedPointerPosition(event) {\n        /** @type {?} */\n        const point = this._getPointerPositionOnPage(event);\n        /** @type {?} */\n        const constrainedPoint = this.constrainPosition ? this.constrainPosition(point, this) : point;\n        /** @type {?} */\n        const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;\n        if (this.lockAxis === 'x' || dropContainerLock === 'x') {\n            constrainedPoint.y = this._pickupPositionOnPage.y;\n        }\n        else if (this.lockAxis === 'y' || dropContainerLock === 'y') {\n            constrainedPoint.x = this._pickupPositionOnPage.x;\n        }\n        if (this._boundaryRect) {\n            const { x: pickupX, y: pickupY } = this._pickupPositionInElement;\n            /** @type {?} */\n            const boundaryRect = this._boundaryRect;\n            /** @type {?} */\n            const previewRect = (/** @type {?} */ (this._previewRect));\n            /** @type {?} */\n            const minY = boundaryRect.top + pickupY;\n            /** @type {?} */\n            const maxY = boundaryRect.bottom - (previewRect.height - pickupY);\n            /** @type {?} */\n            const minX = boundaryRect.left + pickupX;\n            /** @type {?} */\n            const maxX = boundaryRect.right - (previewRect.width - pickupX);\n            constrainedPoint.x = clamp(constrainedPoint.x, minX, maxX);\n            constrainedPoint.y = clamp(constrainedPoint.y, minY, maxY);\n        }\n        return constrainedPoint;\n    }\n    /**\n     * Updates the current drag delta, based on the user's current pointer position on the page.\n     * @private\n     * @param {?} pointerPositionOnPage\n     * @return {?}\n     */\n    _updatePointerDirectionDelta(pointerPositionOnPage) {\n        const { x, y } = pointerPositionOnPage;\n        /** @type {?} */\n        const delta = this._pointerDirectionDelta;\n        /** @type {?} */\n        const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;\n        // Amount of pixels the user has dragged since the last time the direction changed.\n        /** @type {?} */\n        const changeX = Math.abs(x - positionSinceLastChange.x);\n        /** @type {?} */\n        const changeY = Math.abs(y - positionSinceLastChange.y);\n        // Because we handle pointer events on a per-pixel basis, we don't want the delta\n        // to change for every pixel, otherwise anything that depends on it can look erratic.\n        // To make the delta more consistent, we track how much the user has moved since the last\n        // delta change and we only update it after it has reached a certain threshold.\n        if (changeX > this._config.pointerDirectionChangeThreshold) {\n            delta.x = x > positionSinceLastChange.x ? 1 : -1;\n            positionSinceLastChange.x = x;\n        }\n        if (changeY > this._config.pointerDirectionChangeThreshold) {\n            delta.y = y > positionSinceLastChange.y ? 1 : -1;\n            positionSinceLastChange.y = y;\n        }\n        return delta;\n    }\n    /**\n     * Toggles the native drag interactions, based on how many handles are registered.\n     * @private\n     * @return {?}\n     */\n    _toggleNativeDragInteractions() {\n        if (!this._rootElement || !this._handles) {\n            return;\n        }\n        /** @type {?} */\n        const shouldEnable = this._handles.length > 0 || !this.isDragging();\n        if (shouldEnable !== this._nativeInteractionsEnabled) {\n            this._nativeInteractionsEnabled = shouldEnable;\n            toggleNativeDragInteractions(this._rootElement, shouldEnable);\n        }\n    }\n    /**\n     * Removes the manually-added event listeners from the root element.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    _removeRootElementListeners(element) {\n        element.removeEventListener('mousedown', this._pointerDown, activeEventListenerOptions);\n        element.removeEventListener('touchstart', this._pointerDown, passiveEventListenerOptions);\n    }\n    /**\n     * Applies a `transform` to the root element, taking into account any existing transforms on it.\n     * @private\n     * @param {?} x New transform value along the X axis.\n     * @param {?} y New transform value along the Y axis.\n     * @return {?}\n     */\n    _applyRootElementTransform(x, y) {\n        /** @type {?} */\n        const transform = getTransform(x, y);\n        // Cache the previous transform amount only after the first drag sequence, because\n        // we don't want our own transforms to stack on top of each other.\n        if (this._initialTransform == null) {\n            this._initialTransform = this._rootElement.style.transform || '';\n        }\n        // Preserve the previous `transform` value, if there was one. Note that we apply our own\n        // transform before the user's, because things like rotation can affect which direction\n        // the element will be translated towards.\n        this._rootElement.style.transform = this._initialTransform ?\n            transform + ' ' + this._initialTransform : transform;\n    }\n    /**\n     * Gets the distance that the user has dragged during the current drag sequence.\n     * @private\n     * @param {?} currentPosition Current position of the user's pointer.\n     * @return {?}\n     */\n    _getDragDistance(currentPosition) {\n        /** @type {?} */\n        const pickupPosition = this._pickupPositionOnPage;\n        if (pickupPosition) {\n            return { x: currentPosition.x - pickupPosition.x, y: currentPosition.y - pickupPosition.y };\n        }\n        return { x: 0, y: 0 };\n    }\n    /**\n     * Cleans up any cached element dimensions that we don't need after dragging has stopped.\n     * @private\n     * @return {?}\n     */\n    _cleanupCachedDimensions() {\n        this._boundaryRect = this._previewRect = undefined;\n    }\n    /**\n     * Checks whether the element is still inside its boundary after the viewport has been resized.\n     * If not, the position is adjusted so that the element fits again.\n     * @private\n     * @return {?}\n     */\n    _containInsideBoundaryOnResize() {\n        let { x, y } = this._passiveTransform;\n        if ((x === 0 && y === 0) || this.isDragging() || !this._boundaryElement) {\n            return;\n        }\n        /** @type {?} */\n        const boundaryRect = this._boundaryElement.getBoundingClientRect();\n        /** @type {?} */\n        const elementRect = this._rootElement.getBoundingClientRect();\n        /** @type {?} */\n        const leftOverflow = boundaryRect.left - elementRect.left;\n        /** @type {?} */\n        const rightOverflow = elementRect.right - boundaryRect.right;\n        /** @type {?} */\n        const topOverflow = boundaryRect.top - elementRect.top;\n        /** @type {?} */\n        const bottomOverflow = elementRect.bottom - boundaryRect.bottom;\n        // If the element has become wider than the boundary, we can't\n        // do much to make it fit so we just anchor it to the left.\n        if (boundaryRect.width > elementRect.width) {\n            if (leftOverflow > 0) {\n                x += leftOverflow;\n            }\n            if (rightOverflow > 0) {\n                x -= rightOverflow;\n            }\n        }\n        else {\n            x = 0;\n        }\n        // If the element has become taller than the boundary, we can't\n        // do much to make it fit so we just anchor it to the top.\n        if (boundaryRect.height > elementRect.height) {\n            if (topOverflow > 0) {\n                y += topOverflow;\n            }\n            if (bottomOverflow > 0) {\n                y -= bottomOverflow;\n            }\n        }\n        else {\n            y = 0;\n        }\n        if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {\n            this.setFreeDragPosition({ y, x });\n        }\n    }\n}\n/**\n * Gets a 3d `transform` that can be applied to an element.\n * @param {?} x Desired position of the element along the X axis.\n * @param {?} y Desired position of the element along the Y axis.\n * @return {?}\n */\nfunction getTransform(x, y) {\n    // Round the transforms since some browsers will\n    // blur the elements for sub-pixel transforms.\n    return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;\n}\n/**\n * Creates a deep clone of an element.\n * @param {?} node\n * @return {?}\n */\nfunction deepCloneNode(node) {\n    /** @type {?} */\n    const clone = (/** @type {?} */ (node.cloneNode(true)));\n    /** @type {?} */\n    const descendantsWithId = clone.querySelectorAll('[id]');\n    /** @type {?} */\n    const descendantCanvases = node.querySelectorAll('canvas');\n    // Remove the `id` to avoid having multiple elements with the same id on the page.\n    clone.removeAttribute('id');\n    for (let i = 0; i < descendantsWithId.length; i++) {\n        descendantsWithId[i].removeAttribute('id');\n    }\n    // `cloneNode` won't transfer the content of `canvas` elements so we have to do it ourselves.\n    // We match up the cloned canvas to their sources using their index in the DOM.\n    if (descendantCanvases.length) {\n        /** @type {?} */\n        const cloneCanvases = clone.querySelectorAll('canvas');\n        for (let i = 0; i < descendantCanvases.length; i++) {\n            /** @type {?} */\n            const correspondingCloneContext = cloneCanvases[i].getContext('2d');\n            if (correspondingCloneContext) {\n                correspondingCloneContext.drawImage(descendantCanvases[i], 0, 0);\n            }\n        }\n    }\n    return clone;\n}\n/**\n * Clamps a value between a minimum and a maximum.\n * @param {?} value\n * @param {?} min\n * @param {?} max\n * @return {?}\n */\nfunction clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * Helper to remove an element from the DOM and to do all the necessary null checks.\n * @param {?} element Element to be removed.\n * @return {?}\n */\nfunction removeElement(element) {\n    if (element && element.parentNode) {\n        element.parentNode.removeChild(element);\n    }\n}\n/**\n * Determines whether an event is a touch event.\n * @param {?} event\n * @return {?}\n */\nfunction isTouchEvent(event) {\n    // This function is called for every pixel that the user has dragged so we need it to be\n    // as fast as possible. Since we only bind mouse events and touch events, we can assume\n    // that if the event's name starts with `t`, it's a touch event.\n    return event.type[0] === 't';\n}\n/**\n * Gets the element into which the drag preview should be inserted.\n * @param {?} documentRef\n * @return {?}\n */\nfunction getPreviewInsertionPoint(documentRef) {\n    // We can't use the body if the user is in fullscreen mode,\n    // because the preview will render under the fullscreen element.\n    // TODO(crisbeto): dedupe this with the `FullscreenOverlayContainer` eventually.\n    return documentRef.fullscreenElement ||\n        documentRef.webkitFullscreenElement ||\n        documentRef.mozFullScreenElement ||\n        documentRef.msFullscreenElement ||\n        documentRef.body;\n}\n/**\n * Gets the root HTML element of an embedded view.\n * If the root is not an HTML element it gets wrapped in one.\n * @param {?} viewRef\n * @param {?} _document\n * @return {?}\n */\nfunction getRootNode(viewRef, _document) {\n    /** @type {?} */\n    const rootNode = viewRef.rootNodes[0];\n    if (rootNode.nodeType !== _document.ELEMENT_NODE) {\n        /** @type {?} */\n        const wrapper = _document.createElement('div');\n        wrapper.appendChild(rootNode);\n        return wrapper;\n    }\n    return (/** @type {?} */ (rootNode));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Moves an item one index in an array to another.\n * @template T\n * @param {?} array Array in which to move the item.\n * @param {?} fromIndex Starting index of the item.\n * @param {?} toIndex Index to which the item should be moved.\n * @return {?}\n */\nfunction moveItemInArray(array, fromIndex, toIndex) {\n    /** @type {?} */\n    const from = clamp$1(fromIndex, array.length - 1);\n    /** @type {?} */\n    const to = clamp$1(toIndex, array.length - 1);\n    if (from === to) {\n        return;\n    }\n    /** @type {?} */\n    const target = array[from];\n    /** @type {?} */\n    const delta = to < from ? -1 : 1;\n    for (let i = from; i !== to; i += delta) {\n        array[i] = array[i + delta];\n    }\n    array[to] = target;\n}\n/**\n * Moves an item from one array to another.\n * @template T\n * @param {?} currentArray Array from which to transfer the item.\n * @param {?} targetArray Array into which to put the item.\n * @param {?} currentIndex Index of the item in its current array.\n * @param {?} targetIndex Index at which to insert the item.\n * @return {?}\n */\nfunction transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    /** @type {?} */\n    const from = clamp$1(currentIndex, currentArray.length - 1);\n    /** @type {?} */\n    const to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);\n    }\n}\n/**\n * Copies an item from one array to another, leaving it in its\n * original position in current array.\n * @template T\n * @param {?} currentArray Array from which to copy the item.\n * @param {?} targetArray Array into which is copy the item.\n * @param {?} currentIndex Index of the item in its current array.\n * @param {?} targetIndex Index at which to insert the item.\n *\n * @return {?}\n */\nfunction copyArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    /** @type {?} */\n    const to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray[currentIndex]);\n    }\n}\n/**\n * Clamps a number between zero and a maximum.\n * @param {?} value\n * @param {?} max\n * @return {?}\n */\nfunction clamp$1(value, max) {\n    return Math.max(0, Math.min(max, value));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Counter used to generate unique ids for drop refs.\n * @type {?}\n */\nlet _uniqueIdCounter = 0;\n/**\n * Proximity, as a ratio to width/height, at which a\n * dragged item will affect the drop container.\n * @type {?}\n */\nconst DROP_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Proximity, as a ratio to width/height at which to start auto-scrolling the drop list or the\n * viewport. The value comes from trying it out manually until it feels right.\n * @type {?}\n */\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Number of pixels to scroll for each frame when auto-scrolling an element.\n * The value comes from trying it out manually until it feels right.\n * @type {?}\n */\nconst AUTO_SCROLL_STEP = 2;\n/**\n * Reference to a drop list. Used to manipulate or dispose of the container.\n * \\@docs-private\n * @template T\n */\nclass DropListRef {\n    /**\n     * @param {?} element\n     * @param {?} _dragDropRegistry\n     * @param {?} _document\n     * @param {?=} _ngZone\n     * @param {?=} _viewportRuler\n     */\n    constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {\n        this._dragDropRegistry = _dragDropRegistry;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        /**\n         * Unique ID for the drop list.\n         * @deprecated No longer being used. To be removed.\n         * \\@breaking-change 8.0.0\n         */\n        this.id = `cdk-drop-list-ref-${_uniqueIdCounter++}`;\n        /**\n         * Whether starting a dragging sequence from this container is disabled.\n         */\n        this.disabled = false;\n        /**\n         * Whether sorting items within the list is disabled.\n         */\n        this.sortingDisabled = false;\n        /**\n         * Whether auto-scrolling the view when the user\n         * moves their pointer close to the edges is disabled.\n         */\n        this.autoScrollDisabled = false;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = (/**\n         * @return {?}\n         */\n        () => true);\n        /**\n         * Emits right before dragging has started.\n         */\n        this.beforeStarted = new Subject();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new Subject();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new Subject();\n        /**\n         * Emits when the user drops an item inside the container.\n         */\n        this.dropped = new Subject();\n        /**\n         * Emits as the user is swapping items while actively dragging.\n         */\n        this.sorted = new Subject();\n        /**\n         * Whether an item in the list is being dragged.\n         */\n        this._isDragging = false;\n        /**\n         * Cache of the dimensions of all the items inside the container.\n         */\n        this._itemPositions = [];\n        /**\n         * Keeps track of the container's scroll position.\n         */\n        this._scrollPosition = { top: 0, left: 0 };\n        /**\n         * Keeps track of the scroll position of the viewport.\n         */\n        this._viewportScrollPosition = { top: 0, left: 0 };\n        /**\n         * Keeps track of the item that was last swapped with the dragged item, as\n         * well as what direction the pointer was moving in when the swap occured.\n         */\n        this._previousSwap = { drag: (/** @type {?} */ (null)), delta: 0 };\n        /**\n         * Drop lists that are connected to the current one.\n         */\n        this._siblings = [];\n        /**\n         * Direction in which the list is oriented.\n         */\n        this._orientation = 'vertical';\n        /**\n         * Connected siblings that currently have a dragged item.\n         */\n        this._activeSiblings = new Set();\n        /**\n         * Layout direction of the drop list.\n         */\n        this._direction = 'ltr';\n        /**\n         * Subscription to the window being scrolled.\n         */\n        this._viewportScrollSubscription = Subscription.EMPTY;\n        /**\n         * Vertical direction in which the list is currently scrolling.\n         */\n        this._verticalScrollDirection = 0 /* NONE */;\n        /**\n         * Horizontal direction in which the list is currently scrolling.\n         */\n        this._horizontalScrollDirection = 0 /* NONE */;\n        /**\n         * Used to signal to the current auto-scroll sequence when to stop.\n         */\n        this._stopScrollTimers = new Subject();\n        /**\n         * Handles the container being scrolled. Has to be an arrow function to preserve the context.\n         */\n        this._handleScroll = (/**\n         * @return {?}\n         */\n        () => {\n            if (!this.isDragging()) {\n                return;\n            }\n            /** @type {?} */\n            const element = coerceElement(this.element);\n            this._updateAfterScroll(this._scrollPosition, element.scrollTop, element.scrollLeft);\n        });\n        /**\n         * Starts the interval that'll auto-scroll the element.\n         */\n        this._startScrollInterval = (/**\n         * @return {?}\n         */\n        () => {\n            this._stopScrolling();\n            interval(0, animationFrameScheduler)\n                .pipe(takeUntil(this._stopScrollTimers))\n                .subscribe((/**\n             * @return {?}\n             */\n            () => {\n                /** @type {?} */\n                const node = this._scrollNode;\n                if (this._verticalScrollDirection === 1 /* UP */) {\n                    incrementVerticalScroll(node, -AUTO_SCROLL_STEP);\n                }\n                else if (this._verticalScrollDirection === 2 /* DOWN */) {\n                    incrementVerticalScroll(node, AUTO_SCROLL_STEP);\n                }\n                if (this._horizontalScrollDirection === 1 /* LEFT */) {\n                    incrementHorizontalScroll(node, -AUTO_SCROLL_STEP);\n                }\n                else if (this._horizontalScrollDirection === 2 /* RIGHT */) {\n                    incrementHorizontalScroll(node, AUTO_SCROLL_STEP);\n                }\n            }));\n        });\n        /** @type {?} */\n        const nativeNode = this.element = coerceElement(element);\n        this._shadowRoot = getShadowRoot(nativeNode) || _document;\n        _dragDropRegistry.registerDropContainer(this);\n    }\n    /**\n     * Removes the drop list functionality from the DOM element.\n     * @return {?}\n     */\n    dispose() {\n        this._stopScrolling();\n        this._stopScrollTimers.complete();\n        this._removeListeners();\n        this.beforeStarted.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this.sorted.complete();\n        this._activeSiblings.clear();\n        this._scrollNode = (/** @type {?} */ (null));\n        this._dragDropRegistry.removeDropContainer(this);\n    }\n    /**\n     * Whether an item from this list is currently being dragged.\n     * @return {?}\n     */\n    isDragging() {\n        return this._isDragging;\n    }\n    /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    start() {\n        /** @type {?} */\n        const element = coerceElement(this.element);\n        this.beforeStarted.next();\n        this._isDragging = true;\n        this._cacheItems();\n        this._siblings.forEach((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._startReceiving(this)));\n        this._removeListeners();\n        // @breaking-change 9.0.0 Remove check for _ngZone once it's marked as a required param.\n        if (this._ngZone) {\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => element.addEventListener('scroll', this._handleScroll)));\n        }\n        else {\n            element.addEventListener('scroll', this._handleScroll);\n        }\n        // @breaking-change 9.0.0 Remove check for _viewportRuler once it's marked as a required param.\n        if (this._viewportRuler) {\n            this._listenToScrollEvents();\n        }\n    }\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    enter(item, pointerX, pointerY) {\n        this.start();\n        // If sorting is disabled, we want the item to return to its starting\n        // position if the user is returning it to its initial container.\n        /** @type {?} */\n        let newIndex = this.sortingDisabled ? this._draggables.indexOf(item) : -1;\n        if (newIndex === -1) {\n            // We use the coordinates of where the item entered the drop\n            // zone to figure out at which index it should be inserted.\n            newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);\n        }\n        /** @type {?} */\n        const activeDraggables = this._activeDraggables;\n        /** @type {?} */\n        const currentIndex = activeDraggables.indexOf(item);\n        /** @type {?} */\n        const placeholder = item.getPlaceholderElement();\n        /** @type {?} */\n        let newPositionReference = activeDraggables[newIndex];\n        // If the item at the new position is the same as the item that is being dragged,\n        // it means that we're trying to restore the item to its initial position. In this\n        // case we should use the next item from the list as the reference.\n        if (newPositionReference === item) {\n            newPositionReference = activeDraggables[newIndex + 1];\n        }\n        // Since the item may be in the `activeDraggables` already (e.g. if the user dragged it\n        // into another container and back again), we have to ensure that it isn't duplicated.\n        if (currentIndex > -1) {\n            activeDraggables.splice(currentIndex, 1);\n        }\n        // Don't use items that are being dragged as a reference, because\n        // their element has been moved down to the bottom of the body.\n        if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\n            /** @type {?} */\n            const element = newPositionReference.getRootElement();\n            (/** @type {?} */ (element.parentElement)).insertBefore(placeholder, element);\n            activeDraggables.splice(newIndex, 0, item);\n        }\n        else {\n            coerceElement(this.element).appendChild(placeholder);\n            activeDraggables.push(item);\n        }\n        // The transform needs to be cleared so it doesn't throw off the measurements.\n        placeholder.style.transform = '';\n        // Note that the positions were already cached when we called `start` above,\n        // but we need to refresh them since the amount of items has changed.\n        this._cacheItemPositions();\n        this.entered.next({ item, container: this, currentIndex: this.getItemIndex(item) });\n    }\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    exit(item) {\n        this._reset();\n        this.exited.next({ item, container: this });\n    }\n    /**\n     * Drops an item into this container.\n     * \\@breaking-change 9.0.0 `distance` parameter to become required.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @param {?=} distance Distance the user has dragged since the start of the dragging sequence.\n     * @return {?}\n     */\n    drop(item, currentIndex, previousContainer, isPointerOverContainer, distance = { x: 0, y: 0 }) {\n        this._reset();\n        this.dropped.next({\n            item,\n            currentIndex,\n            previousIndex: previousContainer.getItemIndex(item),\n            container: this,\n            previousContainer,\n            isPointerOverContainer,\n            distance\n        });\n    }\n    /**\n     * Sets the draggable items that are a part of this list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} items Items that are a part of this list.\n     * @return {THIS}\n     */\n    withItems(items) {\n        (/** @type {?} */ (this))._draggables = items;\n        items.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        item => item._withDropContainer((/** @type {?} */ (this)))));\n        if ((/** @type {?} */ (this)).isDragging()) {\n            (/** @type {?} */ (this))._cacheItems();\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the layout direction of the drop list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    withDirection(direction) {\n        (/** @type {?} */ (this))._direction = direction;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the containers that are connected to this one. When two or more containers are\n     * connected, the user will be allowed to transfer items between them.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} connectedTo Other containers that the current containers should be connected to.\n     * @return {THIS}\n     */\n    connectedTo(connectedTo) {\n        (/** @type {?} */ (this))._siblings = connectedTo.slice();\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the orientation of the container.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} orientation New orientation for the container.\n     * @return {THIS}\n     */\n    withOrientation(orientation) {\n        (/** @type {?} */ (this))._orientation = orientation;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    getItemIndex(item) {\n        if (!this._isDragging) {\n            return this._draggables.indexOf(item);\n        }\n        // Items are sorted always by top/left in the cache, however they flow differently in RTL.\n        // The rest of the logic still stands no matter what orientation we're in, however\n        // we need to invert the array when determining the index.\n        /** @type {?} */\n        const items = this._orientation === 'horizontal' && this._direction === 'rtl' ?\n            this._itemPositions.slice().reverse() : this._itemPositions;\n        return findIndex(items, (/**\n         * @param {?} currentItem\n         * @return {?}\n         */\n        currentItem => currentItem.drag === item));\n    }\n    /**\n     * Whether the list is able to receive the item that\n     * is currently being dragged inside a connected drop list.\n     * @return {?}\n     */\n    isReceiving() {\n        return this._activeSiblings.size > 0;\n    }\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta Direction in which the pointer is moving along each axis.\n     * @return {?}\n     */\n    _sortItem(item, pointerX, pointerY, pointerDelta) {\n        // Don't sort the item if sorting is disabled or it's out of range.\n        if (this.sortingDisabled || !this._isPointerNearDropContainer(pointerX, pointerY)) {\n            return;\n        }\n        /** @type {?} */\n        const siblings = this._itemPositions;\n        /** @type {?} */\n        const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);\n        if (newIndex === -1 && siblings.length > 0) {\n            return;\n        }\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        const currentIndex = findIndex(siblings, (/**\n         * @param {?} currentItem\n         * @return {?}\n         */\n        currentItem => currentItem.drag === item));\n        /** @type {?} */\n        const siblingAtNewPosition = siblings[newIndex];\n        /** @type {?} */\n        const currentPosition = siblings[currentIndex].clientRect;\n        /** @type {?} */\n        const newPosition = siblingAtNewPosition.clientRect;\n        /** @type {?} */\n        const delta = currentIndex > newIndex ? 1 : -1;\n        this._previousSwap.drag = siblingAtNewPosition.drag;\n        this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;\n        // How many pixels the item's placeholder should be offset.\n        /** @type {?} */\n        const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);\n        // How many pixels all the other items should be offset.\n        /** @type {?} */\n        const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);\n        // Save the previous order of the items before moving the item to its new index.\n        // We use this to check whether an item has been moved as a result of the sorting.\n        /** @type {?} */\n        const oldOrder = siblings.slice();\n        // Shuffle the array in place.\n        moveItemInArray(siblings, currentIndex, newIndex);\n        this.sorted.next({\n            previousIndex: currentIndex,\n            currentIndex: newIndex,\n            container: this,\n            item\n        });\n        siblings.forEach((/**\n         * @param {?} sibling\n         * @param {?} index\n         * @return {?}\n         */\n        (sibling, index) => {\n            // Don't do anything if the position hasn't changed.\n            if (oldOrder[index] === sibling) {\n                return;\n            }\n            /** @type {?} */\n            const isDraggedItem = sibling.drag === item;\n            /** @type {?} */\n            const offset = isDraggedItem ? itemOffset : siblingOffset;\n            /** @type {?} */\n            const elementToOffset = isDraggedItem ? item.getPlaceholderElement() :\n                sibling.drag.getRootElement();\n            // Update the offset to reflect the new position.\n            sibling.offset += offset;\n            // Since we're moving the items with a `transform`, we need to adjust their cached\n            // client rects to reflect their new position, as well as swap their positions in the cache.\n            // Note that we shouldn't use `getBoundingClientRect` here to update the cache, because the\n            // elements may be mid-animation which will give us a wrong result.\n            if (isHorizontal) {\n                // Round the transforms since some browsers will\n                // blur the elements, for sub-pixel transforms.\n                elementToOffset.style.transform = `translate3d(${Math.round(sibling.offset)}px, 0, 0)`;\n                adjustClientRect(sibling.clientRect, 0, offset);\n            }\n            else {\n                elementToOffset.style.transform = `translate3d(0, ${Math.round(sibling.offset)}px, 0)`;\n                adjustClientRect(sibling.clientRect, offset, 0);\n            }\n        }));\n    }\n    /**\n     * Checks whether the user's pointer is close to the edges of either the\n     * viewport or the drop list and starts the auto-scroll sequence.\n     * @param {?} pointerX User's pointer position along the x axis.\n     * @param {?} pointerY User's pointer position along the y axis.\n     * @return {?}\n     */\n    _startScrollingIfNecessary(pointerX, pointerY) {\n        if (this.autoScrollDisabled) {\n            return;\n        }\n        /** @type {?} */\n        let scrollNode;\n        /** @type {?} */\n        let verticalScrollDirection = 0 /* NONE */;\n        /** @type {?} */\n        let horizontalScrollDirection = 0 /* NONE */;\n        // Check whether we should start scrolling the container.\n        if (this._isPointerNearDropContainer(pointerX, pointerY)) {\n            /** @type {?} */\n            const element = coerceElement(this.element);\n            [verticalScrollDirection, horizontalScrollDirection] =\n                getElementScrollDirections(element, this._clientRect, pointerX, pointerY);\n            if (verticalScrollDirection || horizontalScrollDirection) {\n                scrollNode = element;\n            }\n        }\n        // @breaking-change 9.0.0 Remove null check for _viewportRuler once it's a required parameter.\n        // Otherwise check if we can start scrolling the viewport.\n        if (this._viewportRuler && !verticalScrollDirection && !horizontalScrollDirection) {\n            const { width, height } = this._viewportRuler.getViewportSize();\n            /** @type {?} */\n            const clientRect = { width, height, top: 0, right: width, bottom: height, left: 0 };\n            verticalScrollDirection = getVerticalScrollDirection(clientRect, pointerY);\n            horizontalScrollDirection = getHorizontalScrollDirection(clientRect, pointerX);\n            scrollNode = window;\n        }\n        if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection ||\n            horizontalScrollDirection !== this._horizontalScrollDirection ||\n            scrollNode !== this._scrollNode)) {\n            this._verticalScrollDirection = verticalScrollDirection;\n            this._horizontalScrollDirection = horizontalScrollDirection;\n            this._scrollNode = scrollNode;\n            if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {\n                // @breaking-change 9.0.0 Remove null check for `_ngZone` once it is made required.\n                if (this._ngZone) {\n                    this._ngZone.runOutsideAngular(this._startScrollInterval);\n                }\n                else {\n                    this._startScrollInterval();\n                }\n            }\n            else {\n                this._stopScrolling();\n            }\n        }\n    }\n    /**\n     * Stops any currently-running auto-scroll sequences.\n     * @return {?}\n     */\n    _stopScrolling() {\n        this._stopScrollTimers.next();\n    }\n    /**\n     * Caches the position of the drop list.\n     * @private\n     * @return {?}\n     */\n    _cacheOwnPosition() {\n        /** @type {?} */\n        const element = coerceElement(this.element);\n        this._clientRect = getMutableClientRect(element);\n        this._scrollPosition = { top: element.scrollTop, left: element.scrollLeft };\n    }\n    /**\n     * Refreshes the position cache of the items and sibling containers.\n     * @private\n     * @return {?}\n     */\n    _cacheItemPositions() {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        this._itemPositions = this._activeDraggables.map((/**\n         * @param {?} drag\n         * @return {?}\n         */\n        drag => {\n            /** @type {?} */\n            const elementToMeasure = this._dragDropRegistry.isDragging(drag) ?\n                // If the element is being dragged, we have to measure the\n                // placeholder, because the element is hidden.\n                drag.getPlaceholderElement() :\n                drag.getRootElement();\n            return { drag, offset: 0, clientRect: getMutableClientRect(elementToMeasure) };\n        })).sort((/**\n         * @param {?} a\n         * @param {?} b\n         * @return {?}\n         */\n        (a, b) => {\n            return isHorizontal ? a.clientRect.left - b.clientRect.left :\n                a.clientRect.top - b.clientRect.top;\n        }));\n    }\n    /**\n     * Resets the container to its initial state.\n     * @private\n     * @return {?}\n     */\n    _reset() {\n        this._isDragging = false;\n        // TODO(crisbeto): may have to wait for the animations to finish.\n        this._activeDraggables.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        item => item.getRootElement().style.transform = ''));\n        this._siblings.forEach((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._stopReceiving(this)));\n        this._activeDraggables = [];\n        this._itemPositions = [];\n        this._previousSwap.drag = null;\n        this._previousSwap.delta = 0;\n        this._stopScrolling();\n        this._removeListeners();\n    }\n    /**\n     * Gets the offset in pixels by which the items that aren't being dragged should be moved.\n     * @private\n     * @param {?} currentIndex Index of the item currently being dragged.\n     * @param {?} siblings All of the items in the list.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    _getSiblingOffsetPx(currentIndex, siblings, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        const currentPosition = siblings[currentIndex].clientRect;\n        /** @type {?} */\n        const immediateSibling = siblings[currentIndex + delta * -1];\n        /** @type {?} */\n        let siblingOffset = currentPosition[isHorizontal ? 'width' : 'height'] * delta;\n        if (immediateSibling) {\n            /** @type {?} */\n            const start = isHorizontal ? 'left' : 'top';\n            /** @type {?} */\n            const end = isHorizontal ? 'right' : 'bottom';\n            // Get the spacing between the start of the current item and the end of the one immediately\n            // after it in the direction in which the user is dragging, or vice versa. We add it to the\n            // offset in order to push the element to where it will be when it's inline and is influenced\n            // by the `margin` of its siblings.\n            if (delta === -1) {\n                siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];\n            }\n            else {\n                siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];\n            }\n        }\n        return siblingOffset;\n    }\n    /**\n     * Checks whether the pointer coordinates are close to the drop container.\n     * @private\n     * @param {?} pointerX Coordinates along the X axis.\n     * @param {?} pointerY Coordinates along the Y axis.\n     * @return {?}\n     */\n    _isPointerNearDropContainer(pointerX, pointerY) {\n        const { top, right, bottom, left, width, height } = this._clientRect;\n        /** @type {?} */\n        const xThreshold = width * DROP_PROXIMITY_THRESHOLD;\n        /** @type {?} */\n        const yThreshold = height * DROP_PROXIMITY_THRESHOLD;\n        return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\n            pointerX > left - xThreshold && pointerX < right + xThreshold;\n    }\n    /**\n     * Gets the offset in pixels by which the item that is being dragged should be moved.\n     * @private\n     * @param {?} currentPosition Current position of the item.\n     * @param {?} newPosition Position of the item where the current item should be moved.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    _getItemOffsetPx(currentPosition, newPosition, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        let itemOffset = isHorizontal ? newPosition.left - currentPosition.left :\n            newPosition.top - currentPosition.top;\n        // Account for differences in the item width/height.\n        if (delta === -1) {\n            itemOffset += isHorizontal ? newPosition.width - currentPosition.width :\n                newPosition.height - currentPosition.height;\n        }\n        return itemOffset;\n    }\n    /**\n     * Gets the index of an item in the drop container, based on the position of the user's pointer.\n     * @private\n     * @param {?} item Item that is being sorted.\n     * @param {?} pointerX Position of the user's pointer along the X axis.\n     * @param {?} pointerY Position of the user's pointer along the Y axis.\n     * @param {?=} delta Direction in which the user is moving their pointer.\n     * @return {?}\n     */\n    _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        return findIndex(this._itemPositions, (/**\n         * @param {?} __0\n         * @param {?} _\n         * @param {?} array\n         * @return {?}\n         */\n        ({ drag, clientRect }, _, array) => {\n            if (drag === item) {\n                // If there's only one item left in the container, it must be\n                // the dragged item itself so we use it as a reference.\n                return array.length < 2;\n            }\n            if (delta) {\n                /** @type {?} */\n                const direction = isHorizontal ? delta.x : delta.y;\n                // If the user is still hovering over the same item as last time, and they didn't change\n                // the direction in which they're dragging, we don't consider it a direction swap.\n                if (drag === this._previousSwap.drag && direction === this._previousSwap.delta) {\n                    return false;\n                }\n            }\n            return isHorizontal ?\n                // Round these down since most browsers report client rects with\n                // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.\n                pointerX >= Math.floor(clientRect.left) && pointerX <= Math.floor(clientRect.right) :\n                pointerY >= Math.floor(clientRect.top) && pointerY <= Math.floor(clientRect.bottom);\n        }));\n    }\n    /**\n     * Caches the current items in the list and their positions.\n     * @private\n     * @return {?}\n     */\n    _cacheItems() {\n        this._activeDraggables = this._draggables.slice();\n        this._cacheItemPositions();\n        this._cacheOwnPosition();\n    }\n    /**\n     * Updates the internal state of the container after a scroll event has happened.\n     * @private\n     * @param {?} scrollPosition Object that is keeping track of the scroll position.\n     * @param {?} newTop New top scroll position.\n     * @param {?} newLeft New left scroll position.\n     * @param {?=} extraClientRect Extra `ClientRect` object that should be updated, in addition to the\n     *  ones of the drag items. Useful when the viewport has been scrolled and we also need to update\n     *  the `ClientRect` of the list.\n     * @return {?}\n     */\n    _updateAfterScroll(scrollPosition, newTop, newLeft, extraClientRect) {\n        /** @type {?} */\n        const topDifference = scrollPosition.top - newTop;\n        /** @type {?} */\n        const leftDifference = scrollPosition.left - newLeft;\n        if (extraClientRect) {\n            adjustClientRect(extraClientRect, topDifference, leftDifference);\n        }\n        // Since we know the amount that the user has scrolled we can shift all of the client rectangles\n        // ourselves. This is cheaper than re-measuring everything and we can avoid inconsistent\n        // behavior where we might be measuring the element before its position has changed.\n        this._itemPositions.forEach((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ({ clientRect }) => {\n            adjustClientRect(clientRect, topDifference, leftDifference);\n        }));\n        // We need two loops for this, because we want all of the cached\n        // positions to be up-to-date before we re-sort the item.\n        this._itemPositions.forEach((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ({ drag }) => {\n            if (this._dragDropRegistry.isDragging(drag)) {\n                // We need to re-sort the item manually, because the pointer move\n                // events won't be dispatched while the user is scrolling.\n                drag._sortFromLastPointerPosition();\n            }\n        }));\n        scrollPosition.top = newTop;\n        scrollPosition.left = newLeft;\n    }\n    /**\n     * Removes the event listeners associated with this drop list.\n     * @private\n     * @return {?}\n     */\n    _removeListeners() {\n        coerceElement(this.element).removeEventListener('scroll', this._handleScroll);\n        this._viewportScrollSubscription.unsubscribe();\n    }\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param {?} x Pointer position along the X axis.\n     * @param {?} y Pointer position along the Y axis.\n     * @return {?}\n     */\n    _isOverContainer(x, y) {\n        return isInsideClientRect(this._clientRect, x, y);\n    }\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    _getSiblingContainerFromPosition(item, x, y) {\n        return this._siblings.find((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._canReceive(item, x, y)));\n    }\n    /**\n     * Checks whether the drop list can receive the passed-in item.\n     * @param {?} item Item that is being dragged into the list.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    _canReceive(item, x, y) {\n        if (!this.enterPredicate(item, this) || !isInsideClientRect(this._clientRect, x, y)) {\n            return false;\n        }\n        /** @type {?} */\n        const elementFromPoint = (/** @type {?} */ (this._shadowRoot.elementFromPoint(x, y)));\n        // If there's no element at the pointer position, then\n        // the client rect is probably scrolled out of the view.\n        if (!elementFromPoint) {\n            return false;\n        }\n        /** @type {?} */\n        const nativeElement = coerceElement(this.element);\n        // The `ClientRect`, that we're using to find the container over which the user is\n        // hovering, doesn't give us any information on whether the element has been scrolled\n        // out of the view or whether it's overlapping with other containers. This means that\n        // we could end up transferring the item into a container that's invisible or is positioned\n        // below another one. We use the result from `elementFromPoint` to get the top-most element\n        // at the pointer position and to find whether it's one of the intersecting drop containers.\n        return elementFromPoint === nativeElement || nativeElement.contains(elementFromPoint);\n    }\n    /**\n     * Called by one of the connected drop lists when a dragging sequence has started.\n     * @param {?} sibling Sibling in which dragging has started.\n     * @return {?}\n     */\n    _startReceiving(sibling) {\n        /** @type {?} */\n        const activeSiblings = this._activeSiblings;\n        if (!activeSiblings.has(sibling)) {\n            activeSiblings.add(sibling);\n            this._cacheOwnPosition();\n            this._listenToScrollEvents();\n        }\n    }\n    /**\n     * Called by a connected drop list when dragging has stopped.\n     * @param {?} sibling Sibling whose dragging has stopped.\n     * @return {?}\n     */\n    _stopReceiving(sibling) {\n        this._activeSiblings.delete(sibling);\n        this._viewportScrollSubscription.unsubscribe();\n    }\n    /**\n     * Starts listening to scroll events on the viewport.\n     * Used for updating the internal state of the list.\n     * @private\n     * @return {?}\n     */\n    _listenToScrollEvents() {\n        this._viewportScrollPosition = (/** @type {?} */ (this._viewportRuler)).getViewportScrollPosition();\n        this._viewportScrollSubscription = this._dragDropRegistry.scroll.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            if (this.isDragging()) {\n                /** @type {?} */\n                const newPosition = (/** @type {?} */ (this._viewportRuler)).getViewportScrollPosition();\n                this._updateAfterScroll(this._viewportScrollPosition, newPosition.top, newPosition.left, this._clientRect);\n            }\n            else if (this.isReceiving()) {\n                this._cacheOwnPosition();\n            }\n        }));\n    }\n}\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param {?} clientRect `ClientRect` that should be updated.\n * @param {?} top Amount to add to the `top` position.\n * @param {?} left Amount to add to the `left` position.\n * @return {?}\n */\nfunction adjustClientRect(clientRect, top, left) {\n    clientRect.top += top;\n    clientRect.bottom = clientRect.top + clientRect.height;\n    clientRect.left += left;\n    clientRect.right = clientRect.left + clientRect.width;\n}\n/**\n * Finds the index of an item that matches a predicate function. Used as an equivalent\n * of `Array.prototype.findIndex` which isn't part of the standard Google typings.\n * @template T\n * @param {?} array Array in which to look for matches.\n * @param {?} predicate Function used to determine whether an item is a match.\n * @return {?}\n */\nfunction findIndex(array, predicate) {\n    for (let i = 0; i < array.length; i++) {\n        if (predicate(array[i], i, array)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param {?} clientRect ClientRect that is being checked.\n * @param {?} x Coordinates along the X axis.\n * @param {?} y Coordinates along the Y axis.\n * @return {?}\n */\nfunction isInsideClientRect(clientRect, x, y) {\n    const { top, bottom, left, right } = clientRect;\n    return y >= top && y <= bottom && x >= left && x <= right;\n}\n/**\n * Gets a mutable version of an element's bounding `ClientRect`.\n * @param {?} element\n * @return {?}\n */\nfunction getMutableClientRect(element) {\n    /** @type {?} */\n    const clientRect = element.getBoundingClientRect();\n    // We need to clone the `clientRect` here, because all the values on it are readonly\n    // and we need to be able to update them. Also we can't use a spread here, because\n    // the values on a `ClientRect` aren't own properties. See:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n    return {\n        top: clientRect.top,\n        right: clientRect.right,\n        bottom: clientRect.bottom,\n        left: clientRect.left,\n        width: clientRect.width,\n        height: clientRect.height\n    };\n}\n/**\n * Increments the vertical scroll position of a node.\n * @param {?} node Node whose scroll position should change.\n * @param {?} amount Amount of pixels that the `node` should be scrolled.\n * @return {?}\n */\nfunction incrementVerticalScroll(node, amount) {\n    if (node === window) {\n        ((/** @type {?} */ (node))).scrollBy(0, amount);\n    }\n    else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        ((/** @type {?} */ (node))).scrollTop += amount;\n    }\n}\n/**\n * Increments the horizontal scroll position of a node.\n * @param {?} node Node whose scroll position should change.\n * @param {?} amount Amount of pixels that the `node` should be scrolled.\n * @return {?}\n */\nfunction incrementHorizontalScroll(node, amount) {\n    if (node === window) {\n        ((/** @type {?} */ (node))).scrollBy(amount, 0);\n    }\n    else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        ((/** @type {?} */ (node))).scrollLeft += amount;\n    }\n}\n/**\n * Gets whether the vertical auto-scroll direction of a node.\n * @param {?} clientRect Dimensions of the node.\n * @param {?} pointerY Position of the user's pointer along the y axis.\n * @return {?}\n */\nfunction getVerticalScrollDirection(clientRect, pointerY) {\n    const { top, bottom, height } = clientRect;\n    /** @type {?} */\n    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n        return 1 /* UP */;\n    }\n    else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n        return 2 /* DOWN */;\n    }\n    return 0 /* NONE */;\n}\n/**\n * Gets whether the horizontal auto-scroll direction of a node.\n * @param {?} clientRect Dimensions of the node.\n * @param {?} pointerX Position of the user's pointer along the x axis.\n * @return {?}\n */\nfunction getHorizontalScrollDirection(clientRect, pointerX) {\n    const { left, right, width } = clientRect;\n    /** @type {?} */\n    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n        return 1 /* LEFT */;\n    }\n    else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n        return 2 /* RIGHT */;\n    }\n    return 0 /* NONE */;\n}\n/**\n * Gets the directions in which an element node should be scrolled,\n * assuming that the user's pointer is already within it scrollable region.\n * @param {?} element Element for which we should calculate the scroll direction.\n * @param {?} clientRect Bounding client rectangle of the element.\n * @param {?} pointerX Position of the user's pointer along the x axis.\n * @param {?} pointerY Position of the user's pointer along the y axis.\n * @return {?}\n */\nfunction getElementScrollDirections(element, clientRect, pointerX, pointerY) {\n    /** @type {?} */\n    const computedVertical = getVerticalScrollDirection(clientRect, pointerY);\n    /** @type {?} */\n    const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);\n    /** @type {?} */\n    let verticalScrollDirection = 0 /* NONE */;\n    /** @type {?} */\n    let horizontalScrollDirection = 0 /* NONE */;\n    // Note that we here we do some extra checks for whether the element is actually scrollable in\n    // a certain direction and we only assign the scroll direction if it is. We do this so that we\n    // can allow other elements to be scrolled, if the current element can't be scrolled anymore.\n    // This allows us to handle cases where the scroll regions of two scrollable elements overlap.\n    if (computedVertical) {\n        /** @type {?} */\n        const scrollTop = element.scrollTop;\n        if (computedVertical === 1 /* UP */) {\n            if (scrollTop > 0) {\n                verticalScrollDirection = 1 /* UP */;\n            }\n        }\n        else if (element.scrollHeight - scrollTop > element.clientHeight) {\n            verticalScrollDirection = 2 /* DOWN */;\n        }\n    }\n    if (computedHorizontal) {\n        /** @type {?} */\n        const scrollLeft = element.scrollLeft;\n        if (computedHorizontal === 1 /* LEFT */) {\n            if (scrollLeft > 0) {\n                horizontalScrollDirection = 1 /* LEFT */;\n            }\n        }\n        else if (element.scrollWidth - scrollLeft > element.clientWidth) {\n            horizontalScrollDirection = 2 /* RIGHT */;\n        }\n    }\n    return [verticalScrollDirection, horizontalScrollDirection];\n}\n/**\n * Gets the shadow root of an element, if any.\n * @param {?} element\n * @return {?}\n */\nfunction getShadowRoot(element) {\n    if (_supportsShadowDom()) {\n        /** @type {?} */\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\n        if (rootNode instanceof ShadowRoot) {\n            return rootNode;\n        }\n    }\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Event options that can be used to bind an active, capturing event.\n * @type {?}\n */\nconst activeCapturingEventOptions = normalizePassiveListenerOptions({\n    passive: false,\n    capture: true\n});\n/**\n * Service that keeps track of all the drag item and drop container\n * instances, and manages global event listeners on the `document`.\n * \\@docs-private\n * @template I, C\n */\n// Note: this class is generic, rather than referencing CdkDrag and CdkDropList directly, in order\n// to avoid circular imports. If we were to reference them here, importing the registry into the\n// classes that are registering themselves will introduce a circular import.\nclass DragDropRegistry {\n    /**\n     * @param {?} _ngZone\n     * @param {?} _document\n     */\n    constructor(_ngZone, _document) {\n        this._ngZone = _ngZone;\n        /**\n         * Registered drop container instances.\n         */\n        this._dropInstances = new Set();\n        /**\n         * Registered drag item instances.\n         */\n        this._dragInstances = new Set();\n        /**\n         * Drag item instances that are currently being dragged.\n         */\n        this._activeDragInstances = new Set();\n        /**\n         * Keeps track of the event listeners that we've bound to the `document`.\n         */\n        this._globalListeners = new Map();\n        /**\n         * Emits the `touchmove` or `mousemove` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerMove = new Subject();\n        /**\n         * Emits the `touchend` or `mouseup` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerUp = new Subject();\n        /**\n         * Emits when the viewport has been scrolled while the user is dragging an item.\n         */\n        this.scroll = new Subject();\n        /**\n         * Event listener that will prevent the default browser action while the user is dragging.\n         * @param event Event whose default action should be prevented.\n         */\n        this._preventDefaultWhileDragging = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            if (this._activeDragInstances.size) {\n                event.preventDefault();\n            }\n        });\n        this._document = _document;\n    }\n    /**\n     * Adds a drop container to the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    registerDropContainer(drop) {\n        if (!this._dropInstances.has(drop)) {\n            if (this.getDropContainer(drop.id)) {\n                throw Error(`Drop instance with id \"${drop.id}\" has already been registered.`);\n            }\n            this._dropInstances.add(drop);\n        }\n    }\n    /**\n     * Adds a drag item instance to the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    registerDragItem(drag) {\n        this._dragInstances.add(drag);\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\n        // won't preventDefault on a dynamically-added `touchmove` listener.\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n        if (this._dragInstances.size === 1) {\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                // The event handler has to be explicitly active,\n                // because newer browsers make it passive by default.\n                this._document.addEventListener('touchmove', this._preventDefaultWhileDragging, activeCapturingEventOptions);\n            }));\n        }\n    }\n    /**\n     * Removes a drop container from the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    removeDropContainer(drop) {\n        this._dropInstances.delete(drop);\n    }\n    /**\n     * Removes a drag item instance from the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    removeDragItem(drag) {\n        this._dragInstances.delete(drag);\n        this.stopDragging(drag);\n        if (this._dragInstances.size === 0) {\n            this._document.removeEventListener('touchmove', this._preventDefaultWhileDragging, activeCapturingEventOptions);\n        }\n    }\n    /**\n     * Starts the dragging sequence for a drag instance.\n     * @param {?} drag Drag instance which is being dragged.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    startDragging(drag, event) {\n        // Do not process the same drag twice to avoid memory leaks and redundant listeners\n        if (this._activeDragInstances.has(drag)) {\n            return;\n        }\n        this._activeDragInstances.add(drag);\n        if (this._activeDragInstances.size === 1) {\n            /** @type {?} */\n            const isTouchEvent = event.type.startsWith('touch');\n            /** @type {?} */\n            const moveEvent = isTouchEvent ? 'touchmove' : 'mousemove';\n            /** @type {?} */\n            const upEvent = isTouchEvent ? 'touchend' : 'mouseup';\n            // We explicitly bind __active__ listeners here, because newer browsers will default to\n            // passive ones for `mousemove` and `touchmove`. The events need to be active, because we\n            // use `preventDefault` to prevent the page from scrolling while the user is dragging.\n            this._globalListeners\n                .set(moveEvent, {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.pointerMove.next((/** @type {?} */ (e)))),\n                options: activeCapturingEventOptions\n            })\n                .set(upEvent, {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.pointerUp.next((/** @type {?} */ (e)))),\n                options: true\n            })\n                .set('scroll', {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.scroll.next(e)),\n                // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't\n                // the document. See https://github.com/angular/components/issues/17144.\n                options: true\n            })\n                // Preventing the default action on `mousemove` isn't enough to disable text selection\n                // on Safari so we need to prevent the selection event as well. Alternatively this can\n                // be done by setting `user-select: none` on the `body`, however it has causes a style\n                // recalculation which can be expensive on pages with a lot of elements.\n                .set('selectstart', {\n                handler: this._preventDefaultWhileDragging,\n                options: activeCapturingEventOptions\n            });\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                this._globalListeners.forEach((/**\n                 * @param {?} config\n                 * @param {?} name\n                 * @return {?}\n                 */\n                (config, name) => {\n                    this._document.addEventListener(name, config.handler, config.options);\n                }));\n            }));\n        }\n    }\n    /**\n     * Stops dragging a drag item instance.\n     * @param {?} drag\n     * @return {?}\n     */\n    stopDragging(drag) {\n        this._activeDragInstances.delete(drag);\n        if (this._activeDragInstances.size === 0) {\n            this._clearGlobalListeners();\n        }\n    }\n    /**\n     * Gets whether a drag item instance is currently being dragged.\n     * @param {?} drag\n     * @return {?}\n     */\n    isDragging(drag) {\n        return this._activeDragInstances.has(drag);\n    }\n    /**\n     * Gets a drop container by its id.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 8.0.0\n     * @param {?} id\n     * @return {?}\n     */\n    getDropContainer(id) {\n        return Array.from(this._dropInstances).find((/**\n         * @param {?} instance\n         * @return {?}\n         */\n        instance => instance.id === id));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._dragInstances.forEach((/**\n         * @param {?} instance\n         * @return {?}\n         */\n        instance => this.removeDragItem(instance)));\n        this._dropInstances.forEach((/**\n         * @param {?} instance\n         * @return {?}\n         */\n        instance => this.removeDropContainer(instance)));\n        this._clearGlobalListeners();\n        this.pointerMove.complete();\n        this.pointerUp.complete();\n    }\n    /**\n     * Clears out the global event listeners from the `document`.\n     * @private\n     * @return {?}\n     */\n    _clearGlobalListeners() {\n        this._globalListeners.forEach((/**\n         * @param {?} config\n         * @param {?} name\n         * @return {?}\n         */\n        (config, name) => {\n            this._document.removeEventListener(name, config.handler, config.options);\n        }));\n        this._globalListeners.clear();\n    }\n}\nDragDropRegistry.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nDragDropRegistry.ctorParameters = () => [\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n/** @nocollapse */ DragDropRegistry.ngInjectableDef = defineInjectable({ factory: function DragDropRegistry_Factory() { return new DragDropRegistry(inject(NgZone), inject(DOCUMENT)); }, token: DragDropRegistry, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Default configuration to be used when creating a `DragRef`.\n * @type {?}\n */\nconst DEFAULT_CONFIG = {\n    dragStartThreshold: 5,\n    pointerDirectionChangeThreshold: 5\n};\n/**\n * Service that allows for drag-and-drop functionality to be attached to DOM elements.\n */\nclass DragDrop {\n    /**\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewportRuler\n     * @param {?} _dragDropRegistry\n     */\n    constructor(_document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n    }\n    /**\n     * Turns an element into a draggable item.\n     * @template T\n     * @param {?} element Element to which to attach the dragging functionality.\n     * @param {?=} config Object used to configure the dragging behavior.\n     * @return {?}\n     */\n    createDrag(element, config = DEFAULT_CONFIG) {\n        return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry);\n    }\n    /**\n     * Turns an element into a drop list.\n     * @template T\n     * @param {?} element Element to which to attach the drop list functionality.\n     * @return {?}\n     */\n    createDropList(element) {\n        return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);\n    }\n}\nDragDrop.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nDragDrop.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: NgZone },\n    { type: ViewportRuler },\n    { type: DragDropRegistry }\n];\n/** @nocollapse */ DragDrop.ngInjectableDef = defineInjectable({ factory: function DragDrop_Factory() { return new DragDrop(inject(DOCUMENT), inject(NgZone), inject(ViewportRuler), inject(DragDropRegistry)); }, token: DragDrop, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that is used to provide a CdkDropList instance to CdkDrag.\n * Used for avoiding circular imports.\n * @type {?}\n */\nconst CDK_DROP_LIST = new InjectionToken('CDK_DROP_LIST');\n/**\n * Injection token that is used to provide a CdkDropList instance to CdkDrag.\n * Used for avoiding circular imports.\n * @deprecated Use `CDK_DROP_LIST` instead.\n * \\@breaking-change 8.0.0\n * @type {?}\n */\nconst CDK_DROP_LIST_CONTAINER = CDK_DROP_LIST;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that can be used for a `CdkDrag` to provide itself as a parent to the\n * drag-specific child directive (`CdkDragHandle`, `CdkDragPreview` etc.). Used primarily\n * to avoid circular imports.\n * \\@docs-private\n * @type {?}\n */\nconst CDK_DRAG_PARENT = new InjectionToken('CDK_DRAG_PARENT');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Handle that can be used to drag and CdkDrag instance.\n */\nclass CdkDragHandle {\n    /**\n     * @param {?} element\n     * @param {?=} parentDrag\n     */\n    constructor(element, parentDrag) {\n        this.element = element;\n        /**\n         * Emits when the state of the handle has changed.\n         */\n        this._stateChanges = new Subject();\n        this._disabled = false;\n        this._parentDrag = parentDrag;\n        toggleNativeDragInteractions(element.nativeElement, false);\n    }\n    /**\n     * Whether starting to drag through this handle is disabled.\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._stateChanges.next(this);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._stateChanges.complete();\n    }\n}\nCdkDragHandle.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDragHandle]',\n                host: {\n                    'class': 'cdk-drag-handle'\n                }\n            },] },\n];\n/** @nocollapse */\nCdkDragHandle.ctorParameters = () => [\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_DRAG_PARENT,] }, { type: Optional }] }\n];\nCdkDragHandle.propDecorators = {\n    disabled: [{ type: Input, args: ['cdkDragHandleDisabled',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the placeholder of a CdkDrag when\n * it is being dragged. The placeholder is displayed in place of the element being dragged.\n * @template T\n */\nclass CdkDragPlaceholder {\n    /**\n     * @param {?} templateRef\n     */\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCdkDragPlaceholder.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[cdkDragPlaceholder]'\n            },] },\n];\n/** @nocollapse */\nCdkDragPlaceholder.ctorParameters = () => [\n    { type: TemplateRef }\n];\nCdkDragPlaceholder.propDecorators = {\n    data: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the preview\n * of a CdkDrag when it is being dragged.\n * @template T\n */\nclass CdkDragPreview {\n    /**\n     * @param {?} templateRef\n     */\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCdkDragPreview.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[cdkDragPreview]'\n            },] },\n];\n/** @nocollapse */\nCdkDragPreview.ctorParameters = () => [\n    { type: TemplateRef }\n];\nCdkDragPreview.propDecorators = {\n    data: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that can be used to configure the behavior of `CdkDrag`.\n * @type {?}\n */\nconst CDK_DRAG_CONFIG = new InjectionToken('CDK_DRAG_CONFIG', {\n    providedIn: 'root',\n    factory: CDK_DRAG_CONFIG_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction CDK_DRAG_CONFIG_FACTORY() {\n    return { dragStartThreshold: 5, pointerDirectionChangeThreshold: 5 };\n}\n/**\n * Element that can be moved inside a CdkDropList container.\n * @template T\n */\nclass CdkDrag {\n    /**\n     * @param {?} element\n     * @param {?} dropContainer\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewContainerRef\n     * @param {?} config\n     * @param {?} _dir\n     * @param {?} dragDrop\n     * @param {?} _changeDetectorRef\n     */\n    constructor(element, dropContainer, _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef) {\n        this.element = element;\n        this.dropContainer = dropContainer;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewContainerRef = _viewContainerRef;\n        this._dir = _dir;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._destroyed = new Subject();\n        /**\n         * Amount of milliseconds to wait after the user has put their\n         * pointer down before starting to drag the element.\n         */\n        this.dragStartDelay = 0;\n        this._disabled = false;\n        /**\n         * Emits when the user starts dragging the item.\n         */\n        this.started = new EventEmitter();\n        /**\n         * Emits when the user has released a drag item, before any animations have started.\n         */\n        this.released = new EventEmitter();\n        /**\n         * Emits when the user stops dragging an item in the container.\n         */\n        this.ended = new EventEmitter();\n        /**\n         * Emits when the user has moved the item into a new container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes the item its container by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /**\n         * Emits when the user drops the item inside a container.\n         */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = new Observable((/**\n         * @param {?} observer\n         * @return {?}\n         */\n        (observer) => {\n            /** @type {?} */\n            const subscription = this._dragRef.moved.pipe(map((/**\n             * @param {?} movedEvent\n             * @return {?}\n             */\n            movedEvent => ({\n                source: this,\n                pointerPosition: movedEvent.pointerPosition,\n                event: movedEvent.event,\n                delta: movedEvent.delta,\n                distance: movedEvent.distance\n            })))).subscribe(observer);\n            return (/**\n             * @return {?}\n             */\n            () => {\n                subscription.unsubscribe();\n            });\n        }));\n        this._dragRef = dragDrop.createDrag(element, config);\n        this._dragRef.data = this;\n        this._syncInputs(this._dragRef);\n        this._handleEvents(this._dragRef);\n    }\n    /**\n     * Selector that will be used to determine the element to which the draggable's position will\n     * be constrained. Matching starts from the element's parent and goes up the DOM until a matching\n     * element has been found\n     * @deprecated Use `boundaryElement` instead.\n     * \\@breaking-change 9.0.0\n     * @return {?}\n     */\n    get boundaryElementSelector() {\n        return typeof this.boundaryElement === 'string' ? this.boundaryElement : (/** @type {?} */ (undefined));\n    }\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    set boundaryElementSelector(selector) {\n        this.boundaryElement = selector;\n    }\n    /**\n     * Whether starting to drag this element is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || (this.dropContainer && this.dropContainer.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._dragRef.disabled = this._disabled;\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    getPlaceholderElement() {\n        return this._dragRef.getPlaceholderElement();\n    }\n    /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    getRootElement() {\n        return this._dragRef.getRootElement();\n    }\n    /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    reset() {\n        this._dragRef.reset();\n    }\n    /**\n     * Gets the pixel coordinates of the draggable outside of a drop container.\n     * @return {?}\n     */\n    getFreeDragPosition() {\n        return this._dragRef.getFreeDragPosition();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        // We need to wait for the zone to stabilize, in order for the reference\n        // element to be in the proper place in the DOM. This is mostly relevant\n        // for draggable elements inside portals since they get stamped out in\n        // their original DOM position and then they get transferred to the portal.\n        this._ngZone.onStable.asObservable()\n            .pipe(take(1), takeUntil(this._destroyed))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._updateRootElement();\n            // Listen for any newly-added handles.\n            this._handles.changes.pipe(startWith(this._handles), \n            // Sync the new handles with the DragRef.\n            tap((/**\n             * @param {?} handles\n             * @return {?}\n             */\n            (handles) => {\n                /** @type {?} */\n                const childHandleElements = handles\n                    .filter((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => handle._parentDrag === this))\n                    .map((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => handle.element));\n                this._dragRef.withHandles(childHandleElements);\n            })), \n            // Listen if the state of any of the handles changes.\n            switchMap((/**\n             * @param {?} handles\n             * @return {?}\n             */\n            (handles) => {\n                return merge(...handles.map((/**\n                 * @param {?} item\n                 * @return {?}\n                 */\n                item => item._stateChanges)));\n            })), takeUntil(this._destroyed)).subscribe((/**\n             * @param {?} handleInstance\n             * @return {?}\n             */\n            handleInstance => {\n                // Enabled/disable the handle that changed in the DragRef.\n                /** @type {?} */\n                const dragRef = this._dragRef;\n                /** @type {?} */\n                const handle = handleInstance.element.nativeElement;\n                handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);\n            }));\n            if (this.freeDragPosition) {\n                this._dragRef.setFreeDragPosition(this.freeDragPosition);\n            }\n        }));\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        /** @type {?} */\n        const rootSelectorChange = changes['rootElementSelector'];\n        /** @type {?} */\n        const positionChange = changes['freeDragPosition'];\n        // We don't have to react to the first change since it's being\n        // handled in `ngAfterViewInit` where it needs to be deferred.\n        if (rootSelectorChange && !rootSelectorChange.firstChange) {\n            this._updateRootElement();\n        }\n        // Skip the first change since it's being handled in `ngAfterViewInit`.\n        if (positionChange && !positionChange.firstChange && this.freeDragPosition) {\n            this._dragRef.setFreeDragPosition(this.freeDragPosition);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n        this._dragRef.dispose();\n    }\n    /**\n     * Syncs the root element with the `DragRef`.\n     * @private\n     * @return {?}\n     */\n    _updateRootElement() {\n        /** @type {?} */\n        const element = this.element.nativeElement;\n        /** @type {?} */\n        const rootElement = this.rootElementSelector ?\n            getClosestMatchingAncestor(element, this.rootElementSelector) : element;\n        if (rootElement && rootElement.nodeType !== this._document.ELEMENT_NODE) {\n            throw Error(`cdkDrag must be attached to an element node. ` +\n                `Currently attached to \"${rootElement.nodeName}\".`);\n        }\n        this._dragRef.withRootElement(rootElement || element);\n    }\n    /**\n     * Gets the boundary element, based on the `boundaryElement` value.\n     * @private\n     * @return {?}\n     */\n    _getBoundaryElement() {\n        /** @type {?} */\n        const boundary = this.boundaryElement;\n        if (!boundary) {\n            return null;\n        }\n        if (typeof boundary === 'string') {\n            return getClosestMatchingAncestor(this.element.nativeElement, boundary);\n        }\n        /** @type {?} */\n        const element = coerceElement(boundary);\n        if (isDevMode() && !element.contains(this.element.nativeElement)) {\n            throw Error('Draggable element is not inside of the node passed into cdkDragBoundary.');\n        }\n        return element;\n    }\n    /**\n     * Syncs the inputs of the CdkDrag with the options of the underlying DragRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _syncInputs(ref) {\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            if (!ref.isDragging()) {\n                /** @type {?} */\n                const dir = this._dir;\n                /** @type {?} */\n                const placeholder = this._placeholderTemplate ? {\n                    template: this._placeholderTemplate.templateRef,\n                    context: this._placeholderTemplate.data,\n                    viewContainer: this._viewContainerRef\n                } : null;\n                /** @type {?} */\n                const preview = this._previewTemplate ? {\n                    template: this._previewTemplate.templateRef,\n                    context: this._previewTemplate.data,\n                    viewContainer: this._viewContainerRef\n                } : null;\n                ref.disabled = this.disabled;\n                ref.lockAxis = this.lockAxis;\n                ref.dragStartDelay = coerceNumberProperty(this.dragStartDelay);\n                ref.constrainPosition = this.constrainPosition;\n                ref\n                    .withBoundaryElement(this._getBoundaryElement())\n                    .withPlaceholderTemplate(placeholder)\n                    .withPreviewTemplate(preview);\n                if (dir) {\n                    ref.withDirection(dir.value);\n                }\n            }\n        }));\n    }\n    /**\n     * Handles the events from the underlying `DragRef`.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _handleEvents(ref) {\n        ref.started.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.started.emit({ source: this });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.released.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.released.emit({ source: this });\n        }));\n        ref.ended.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.ended.emit({ source: this, distance: event.distance });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.entered.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.entered.emit({\n                container: event.container.data,\n                item: this,\n                currentIndex: event.currentIndex\n            });\n        }));\n        ref.exited.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.exited.emit({\n                container: event.container.data,\n                item: this\n            });\n        }));\n        ref.dropped.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.dropped.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                previousContainer: event.previousContainer.data,\n                container: event.container.data,\n                isPointerOverContainer: event.isPointerOverContainer,\n                item: this,\n                distance: event.distance\n            });\n        }));\n    }\n}\nCdkDrag.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDrag]',\n                exportAs: 'cdkDrag',\n                host: {\n                    'class': 'cdk-drag',\n                    '[class.cdk-drag-disabled]': 'disabled',\n                    '[class.cdk-drag-dragging]': '_dragRef.isDragging()',\n                },\n                providers: [{ provide: CDK_DRAG_PARENT, useExisting: CdkDrag }]\n            },] },\n];\n/** @nocollapse */\nCdkDrag.ctorParameters = () => [\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_DROP_LIST,] }, { type: Optional }, { type: SkipSelf }] },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: NgZone },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_DRAG_CONFIG,] }] },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: DragDrop },\n    { type: ChangeDetectorRef }\n];\nCdkDrag.propDecorators = {\n    _handles: [{ type: ContentChildren, args: [CdkDragHandle, { descendants: true },] }],\n    _previewTemplate: [{ type: ContentChild, args: [CdkDragPreview, { static: false },] }],\n    _placeholderTemplate: [{ type: ContentChild, args: [CdkDragPlaceholder, { static: false },] }],\n    data: [{ type: Input, args: ['cdkDragData',] }],\n    lockAxis: [{ type: Input, args: ['cdkDragLockAxis',] }],\n    rootElementSelector: [{ type: Input, args: ['cdkDragRootElement',] }],\n    boundaryElement: [{ type: Input, args: ['cdkDragBoundary',] }],\n    dragStartDelay: [{ type: Input, args: ['cdkDragStartDelay',] }],\n    freeDragPosition: [{ type: Input, args: ['cdkDragFreeDragPosition',] }],\n    disabled: [{ type: Input, args: ['cdkDragDisabled',] }],\n    constrainPosition: [{ type: Input, args: ['cdkDragConstrainPosition',] }],\n    started: [{ type: Output, args: ['cdkDragStarted',] }],\n    released: [{ type: Output, args: ['cdkDragReleased',] }],\n    ended: [{ type: Output, args: ['cdkDragEnded',] }],\n    entered: [{ type: Output, args: ['cdkDragEntered',] }],\n    exited: [{ type: Output, args: ['cdkDragExited',] }],\n    dropped: [{ type: Output, args: ['cdkDragDropped',] }],\n    moved: [{ type: Output, args: ['cdkDragMoved',] }]\n};\n/**\n * Gets the closest ancestor of an element that matches a selector.\n * @param {?} element\n * @param {?} selector\n * @return {?}\n */\nfunction getClosestMatchingAncestor(element, selector) {\n    /** @type {?} */\n    let currentElement = (/** @type {?} */ (element.parentElement));\n    while (currentElement) {\n        // IE doesn't support `matches` so we have to fall back to `msMatchesSelector`.\n        if (currentElement.matches ? currentElement.matches(selector) :\n            ((/** @type {?} */ (currentElement))).msMatchesSelector(selector)) {\n            return currentElement;\n        }\n        currentElement = currentElement.parentElement;\n    }\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Declaratively connects sibling `cdkDropList` instances together. All of the `cdkDropList`\n * elements that are placed inside a `cdkDropListGroup` will be connected to each other\n * automatically. Can be used as an alternative to the `cdkDropListConnectedTo` input\n * from `cdkDropList`.\n * @template T\n */\nclass CdkDropListGroup {\n    constructor() {\n        /**\n         * Drop lists registered inside the group.\n         */\n        this._items = new Set();\n        this._disabled = false;\n    }\n    /**\n     * Whether starting a dragging sequence from inside this group is disabled.\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._items.clear();\n    }\n}\nCdkDropListGroup.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDropListGroup]',\n                exportAs: 'cdkDropListGroup',\n            },] },\n];\nCdkDropListGroup.propDecorators = {\n    disabled: [{ type: Input, args: ['cdkDropListGroupDisabled',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Counter used to generate unique ids for drop zones.\n * @type {?}\n */\nlet _uniqueIdCounter$1 = 0;\nconst 0 = undefined;\n// @breaking-change 8.0.0 `CdkDropList` implements `CdkDropListContainer` for backwards\n// compatiblity. The implements clause, as well as all the methods that it enforces can\n// be removed when `CdkDropListContainer` is deleted.\n/**\n * Container that wraps a set of draggable items.\n * @template T\n */\nclass CdkDropList {\n    /**\n     * @param {?} element\n     * @param {?} dragDrop\n     * @param {?} _changeDetectorRef\n     * @param {?=} _dir\n     * @param {?=} _group\n     */\n    constructor(element, dragDrop, _changeDetectorRef, _dir, _group) {\n        this.element = element;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = _dir;\n        this._group = _group;\n        /**\n         * Emits when the list has been destroyed.\n         */\n        this._destroyed = new Subject();\n        /**\n         * Other draggable containers that this container is connected to and into which the\n         * container's items can be transferred. Can either be references to other drop containers,\n         * or their unique IDs.\n         */\n        this.connectedTo = [];\n        /**\n         * Direction in which the list is oriented.\n         */\n        this.orientation = 'vertical';\n        /**\n         * Unique ID for the drop zone. Can be used as a reference\n         * in the `connectedTo` of another `CdkDropList`.\n         */\n        this.id = `cdk-drop-list-${_uniqueIdCounter$1++}`;\n        this._disabled = false;\n        this._sortingDisabled = false;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = (/**\n         * @return {?}\n         */\n        () => true);\n        /**\n         * Whether to auto-scroll the view when the user moves their pointer close to the edges.\n         */\n        this.autoScrollDisabled = false;\n        /**\n         * Emits when the user drops an item inside the container.\n         */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /**\n         * Emits as the user is swapping items while actively dragging.\n         */\n        this.sorted = new EventEmitter();\n        this._dropListRef = dragDrop.createDropList(element);\n        this._dropListRef.data = this;\n        this._dropListRef.enterPredicate = (/**\n         * @param {?} drag\n         * @param {?} drop\n         * @return {?}\n         */\n        (drag, drop) => {\n            return this.enterPredicate(drag.data, drop.data);\n        });\n        this._syncInputs(this._dropListRef);\n        this._handleEvents(this._dropListRef);\n        CdkDropList._dropLists.push(this);\n        if (_group) {\n            _group._items.add(this);\n        }\n    }\n    /**\n     * Whether starting a dragging sequence from this container is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || (!!this._group && this._group.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n    }\n    /**\n     * Whether sorting within this drop list is disabled.\n     * @return {?}\n     */\n    get sortingDisabled() { return this._sortingDisabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set sortingDisabled(value) {\n        this._sortingDisabled = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._draggables.changes\n            .pipe(startWith(this._draggables), takeUntil(this._destroyed))\n            .subscribe((/**\n         * @param {?} items\n         * @return {?}\n         */\n        (items) => {\n            this._dropListRef.withItems(items.map((/**\n             * @param {?} drag\n             * @return {?}\n             */\n            drag => drag._dragRef)));\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        /** @type {?} */\n        const index = CdkDropList._dropLists.indexOf(this);\n        if (index > -1) {\n            CdkDropList._dropLists.splice(index, 1);\n        }\n        if (this._group) {\n            this._group._items.delete(this);\n        }\n        this._dropListRef.dispose();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    start() {\n        this._dropListRef.start();\n    }\n    /**\n     * Drops an item into this container.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @return {?}\n     */\n    drop(item, currentIndex, previousContainer, isPointerOverContainer) {\n        this._dropListRef.drop(item._dragRef, currentIndex, ((/** @type {?} */ (previousContainer)))._dropListRef, isPointerOverContainer);\n    }\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    enter(item, pointerX, pointerY) {\n        this._dropListRef.enter(item._dragRef, pointerX, pointerY);\n    }\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    exit(item) {\n        this._dropListRef.exit(item._dragRef);\n    }\n    /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    getItemIndex(item) {\n        return this._dropListRef.getItemIndex(item._dragRef);\n    }\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta Direction in which the pointer is moving along each axis.\n     * @return {?}\n     */\n    _sortItem(item, pointerX, pointerY, pointerDelta) {\n        return this._dropListRef._sortItem(item._dragRef, pointerX, pointerY, pointerDelta);\n    }\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    _getSiblingContainerFromPosition(item, x, y) {\n        /** @type {?} */\n        const result = this._dropListRef._getSiblingContainerFromPosition(item._dragRef, x, y);\n        return result ? result.data : null;\n    }\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param {?} x Pointer position along the X axis.\n     * @param {?} y Pointer position along the Y axis.\n     * @return {?}\n     */\n    _isOverContainer(x, y) {\n        return this._dropListRef._isOverContainer(x, y);\n    }\n    /**\n     * Syncs the inputs of the CdkDropList with the options of the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _syncInputs(ref) {\n        if (this._dir) {\n            this._dir.change\n                .pipe(startWith(this._dir.value), takeUntil(this._destroyed))\n                .subscribe((/**\n             * @param {?} value\n             * @return {?}\n             */\n            value => ref.withDirection(value)));\n        }\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const siblings = coerceArray(this.connectedTo).map((/**\n             * @param {?} drop\n             * @return {?}\n             */\n            drop => {\n                return typeof drop === 'string' ?\n                    (/** @type {?} */ (CdkDropList._dropLists.find((/**\n                     * @param {?} list\n                     * @return {?}\n                     */\n                    list => list.id === drop)))) : drop;\n            }));\n            if (this._group) {\n                this._group._items.forEach((/**\n                 * @param {?} drop\n                 * @return {?}\n                 */\n                drop => {\n                    if (siblings.indexOf(drop) === -1) {\n                        siblings.push(drop);\n                    }\n                }));\n            }\n            ref.disabled = this.disabled;\n            ref.lockAxis = this.lockAxis;\n            ref.sortingDisabled = this.sortingDisabled;\n            ref.autoScrollDisabled = this.autoScrollDisabled;\n            ref\n                .connectedTo(siblings.filter((/**\n             * @param {?} drop\n             * @return {?}\n             */\n            drop => drop && drop !== this)).map((/**\n             * @param {?} list\n             * @return {?}\n             */\n            list => list._dropListRef)))\n                .withOrientation(this.orientation);\n        }));\n    }\n    /**\n     * Handles events from the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _handleEvents(ref) {\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.entered.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.entered.emit({\n                container: this,\n                item: event.item.data,\n                currentIndex: event.currentIndex\n            });\n        }));\n        ref.exited.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.exited.emit({\n                container: this,\n                item: event.item.data\n            });\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.sorted.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.sorted.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                container: this,\n                item: event.item.data\n            });\n        }));\n        ref.dropped.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.dropped.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                previousContainer: event.previousContainer.data,\n                container: event.container.data,\n                item: event.item.data,\n                isPointerOverContainer: event.isPointerOverContainer,\n                distance: event.distance\n            });\n            // Mark for check since all of these events run outside of change\n            // detection and we're not guaranteed for something else to have triggered it.\n            this._changeDetectorRef.markForCheck();\n        }));\n    }\n}\n/**\n * Keeps track of the drop lists that are currently on the page.\n */\nCdkDropList._dropLists = [];\nCdkDropList.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDropList], cdk-drop-list',\n                exportAs: 'cdkDropList',\n                providers: [\n                    // Prevent child drop lists from picking up the same group as their parent.\n                    { provide: CdkDropListGroup, useValue: 0 },\n                    { provide: CDK_DROP_LIST_CONTAINER, useExisting: CdkDropList },\n                ],\n                host: {\n                    'class': 'cdk-drop-list',\n                    '[id]': 'id',\n                    '[class.cdk-drop-list-disabled]': 'disabled',\n                    '[class.cdk-drop-list-dragging]': '_dropListRef.isDragging()',\n                    '[class.cdk-drop-list-receiving]': '_dropListRef.isReceiving()',\n                }\n            },] },\n];\n/** @nocollapse */\nCdkDropList.ctorParameters = () => [\n    { type: ElementRef },\n    { type: DragDrop },\n    { type: ChangeDetectorRef },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: CdkDropListGroup, decorators: [{ type: Optional }, { type: SkipSelf }] }\n];\nCdkDropList.propDecorators = {\n    _draggables: [{ type: ContentChildren, args: [forwardRef((/**\n                 * @return {?}\n                 */\n                () => CdkDrag)), {\n                    // Explicitly set to false since some of the logic below makes assumptions about it.\n                    // The `.withItems` call below should be updated if we ever need to switch this to `true`.\n                    descendants: false\n                },] }],\n    connectedTo: [{ type: Input, args: ['cdkDropListConnectedTo',] }],\n    data: [{ type: Input, args: ['cdkDropListData',] }],\n    orientation: [{ type: Input, args: ['cdkDropListOrientation',] }],\n    id: [{ type: Input }],\n    lockAxis: [{ type: Input, args: ['cdkDropListLockAxis',] }],\n    disabled: [{ type: Input, args: ['cdkDropListDisabled',] }],\n    sortingDisabled: [{ type: Input, args: ['cdkDropListSortingDisabled',] }],\n    enterPredicate: [{ type: Input, args: ['cdkDropListEnterPredicate',] }],\n    autoScrollDisabled: [{ type: Input, args: ['cdkDropListAutoScrollDisabled',] }],\n    dropped: [{ type: Output, args: ['cdkDropListDropped',] }],\n    entered: [{ type: Output, args: ['cdkDropListEntered',] }],\n    exited: [{ type: Output, args: ['cdkDropListExited',] }],\n    sorted: [{ type: Output, args: ['cdkDropListSorted',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass DragDropModule {\n}\nDragDropModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    CdkDropList,\n                    CdkDropListGroup,\n                    CdkDrag,\n                    CdkDragHandle,\n                    CdkDragPreview,\n                    CdkDragPlaceholder,\n                ],\n                exports: [\n                    CdkDropList,\n                    CdkDropListGroup,\n                    CdkDrag,\n                    CdkDragHandle,\n                    CdkDragPreview,\n                    CdkDragPlaceholder,\n                ],\n                providers: [\n                    DragDrop,\n                ]\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { DragDrop, DragRef, DropListRef, CdkDropList, CDK_DROP_LIST, CDK_DROP_LIST_CONTAINER, moveItemInArray, transferArrayItem, copyArrayItem, DragDropModule, DragDropRegistry, CdkDropListGroup, CDK_DRAG_CONFIG_FACTORY, CDK_DRAG_CONFIG, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder, CDK_DRAG_PARENT as b };\n//# sourceMappingURL=drag-drop.js.map\n","export default \"<ion-header>\\r\\n  <ion-toolbar>\\r\\n    <ion-buttons slot=\\\"start\\\">\\r\\n      <ion-back-button></ion-back-button>\\r\\n    </ion-buttons>\\r\\n    <ion-title>Drag Drop</ion-title>\\r\\n  </ion-toolbar>\\r\\n</ion-header>\\r\\n\\r\\n<ion-content class=\\\"ion-padding\\\">\\r\\n  <div class=\\\"example-container\\\">\\r\\n    <h2>To do</h2>\\r\\n\\r\\n    <div cdkDropList #todoList=\\\"cdkDropList\\\" [cdkDropListData]=\\\"todo\\\" [cdkDropListConnectedTo]=\\\"[doneList]\\\"\\r\\n      class=\\\"example-list\\\" (cdkDropListDropped)=\\\"drop($event)\\\">\\r\\n      <div class=\\\"example-box\\\" *ngFor=\\\"let item of todo\\\" cdkDrag>{{item}}</div>\\r\\n    </div>\\r\\n  </div>\\r\\n\\r\\n  <div class=\\\"example-container\\\">\\r\\n    <h2>Done</h2>\\r\\n\\r\\n    <div cdkDropList #doneList=\\\"cdkDropList\\\" [cdkDropListData]=\\\"done\\\" [cdkDropListConnectedTo]=\\\"[todoList]\\\"\\r\\n      class=\\\"example-list\\\" (cdkDropListDropped)=\\\"drop($event)\\\">\\r\\n      <div class=\\\"example-box\\\" *ngFor=\\\"let item of done\\\" cdkDrag>{{item}}</div>\\r\\n    </div>\\r\\n  </div>\\r\\n\\r\\n  <div class=\\\"example-box-basic\\\" cdkDrag>\\r\\n    Drag me around\\r\\n  </div>\\r\\n</ion-content>\"","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { Routes, RouterModule } from '@angular/router';\r\n\r\nimport { IonicModule } from '@ionic/angular';\r\n\r\nimport { MatDragDropPage } from './mat-drag-drop.page';\r\nimport { DragDropModule } from '@angular/cdk/drag-drop';\r\n\r\nconst routes: Routes = [\r\n  {\r\n    path: '',\r\n    component: MatDragDropPage\r\n  }\r\n];\r\n\r\n@NgModule({\r\n  imports: [\r\n    CommonModule,\r\n    FormsModule,\r\n    IonicModule,\r\n    RouterModule.forChild(routes),\r\n    DragDropModule\r\n  ],\r\n  declarations: [MatDragDropPage]\r\n})\r\nexport class MatDragDropPageModule { }\r\n","export default \".example-container {\\n  width: 400px;\\n  max-width: 100%;\\n  margin: 0 25px 25px 0;\\n  display: inline-block;\\n  vertical-align: top;\\n}\\n\\n.example-list {\\n  border: solid 1px #ccc;\\n  min-height: 60px;\\n  background: white;\\n  border-radius: 4px;\\n  overflow: hidden;\\n  display: block;\\n}\\n\\n.example-box {\\n  padding: 20px 10px;\\n  border-bottom: solid 1px #ccc;\\n  color: rgba(0, 0, 0, 0.87);\\n  display: flex;\\n  flex-direction: row;\\n  align-items: center;\\n  justify-content: space-between;\\n  box-sizing: border-box;\\n  cursor: move;\\n  background: white;\\n  font-size: 14px;\\n}\\n\\n.cdk-drag-preview {\\n  box-sizing: border-box;\\n  border-radius: 4px;\\n  box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);\\n}\\n\\n.cdk-drag-placeholder {\\n  opacity: 0;\\n}\\n\\n.cdk-drag-animating {\\n  transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);\\n}\\n\\n.example-box:last-child {\\n  border: none;\\n}\\n\\n.example-list.cdk-drop-list-dragging .example-box:not(.cdk-drag-placeholder) {\\n  transition: transform 250ms cubic-bezier(0, 0, 0.2, 1);\\n}\\n\\n.example-box-basic:active {\\n  box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);\\n}\\n\\n.example-box-basic {\\n  width: 200px;\\n  height: 200px;\\n  border: solid 1px #ccc;\\n  color: rgba(0, 0, 0, 0.87);\\n  cursor: move;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  text-align: center;\\n  background: #fff;\\n  border-radius: 4px;\\n  position: relative;\\n  z-index: 1;\\n  transition: box-shadow 200ms cubic-bezier(0, 0, 0.2, 1);\\n  box-shadow: 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);\\n}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvcGFnZXMvYW5ndWxhci1tYXRlcmlhbC9jb21wb25lbnRzL21hdC1kcmFnLWRyb3AvQzpcXFVzZXJzXFxzYWJhZGlcXERvY3VtZW50c1xcUHJvamV0b3NcXF9pb25pY1xcaW9uaWM0LWNvbXBvbmVudHMvc3JjXFxhcHBcXHBhZ2VzXFxhbmd1bGFyLW1hdGVyaWFsXFxjb21wb25lbnRzXFxtYXQtZHJhZy1kcm9wXFxtYXQtZHJhZy1kcm9wLnBhZ2Uuc2NzcyIsInNyYy9hcHAvcGFnZXMvYW5ndWxhci1tYXRlcmlhbC9jb21wb25lbnRzL21hdC1kcmFnLWRyb3AvbWF0LWRyYWctZHJvcC5wYWdlLnNjc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7RUFDRSxZQUFBO0VBQ0EsZUFBQTtFQUNBLHFCQUFBO0VBQ0EscUJBQUE7RUFDQSxtQkFBQTtBQ0NGOztBREVBO0VBQ0Usc0JBQUE7RUFDQSxnQkFBQTtFQUNBLGlCQUFBO0VBQ0Esa0JBQUE7RUFDQSxnQkFBQTtFQUNBLGNBQUE7QUNDRjs7QURFQTtFQUNFLGtCQUFBO0VBQ0EsNkJBQUE7RUFDQSwwQkFBQTtFQUNBLGFBQUE7RUFDQSxtQkFBQTtFQUNBLG1CQUFBO0VBQ0EsOEJBQUE7RUFDQSxzQkFBQTtFQUNBLFlBQUE7RUFDQSxpQkFBQTtFQUNBLGVBQUE7QUNDRjs7QURFQTtFQUNFLHNCQUFBO0VBQ0Esa0JBQUE7RUFDQSxxSEFBQTtBQ0NGOztBREVBO0VBQ0UsVUFBQTtBQ0NGOztBREVBO0VBQ0Usc0RBQUE7QUNDRjs7QURFQTtFQUNFLFlBQUE7QUNDRjs7QURFQTtFQUNFLHNEQUFBO0FDQ0Y7O0FERUE7RUFDRSxxSEFBQTtBQ0NGOztBREVBO0VBQ0UsWUFBQTtFQUNBLGFBQUE7RUFDQSxzQkFBQTtFQUNBLDBCQUFBO0VBQ0EsWUFBQTtFQUNBLGFBQUE7RUFDQSx1QkFBQTtFQUNBLG1CQUFBO0VBQ0Esa0JBQUE7RUFDQSxnQkFBQTtFQUNBLGtCQUFBO0VBQ0Esa0JBQUE7RUFDQSxVQUFBO0VBQ0EsdURBQUE7RUFDQSwrR0FBQTtBQ0NGIiwiZmlsZSI6InNyYy9hcHAvcGFnZXMvYW5ndWxhci1tYXRlcmlhbC9jb21wb25lbnRzL21hdC1kcmFnLWRyb3AvbWF0LWRyYWctZHJvcC5wYWdlLnNjc3MiLCJzb3VyY2VzQ29udGVudCI6WyIuZXhhbXBsZS1jb250YWluZXIge1xyXG4gIHdpZHRoOiA0MDBweDtcclxuICBtYXgtd2lkdGg6IDEwMCU7XHJcbiAgbWFyZ2luOiAwIDI1cHggMjVweCAwO1xyXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xyXG59XHJcblxyXG4uZXhhbXBsZS1saXN0IHtcclxuICBib3JkZXI6IHNvbGlkIDFweCAjY2NjO1xyXG4gIG1pbi1oZWlnaHQ6IDYwcHg7XHJcbiAgYmFja2dyb3VuZDogd2hpdGU7XHJcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xyXG4gIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgZGlzcGxheTogYmxvY2s7XHJcbn1cclxuXHJcbi5leGFtcGxlLWJveCB7XHJcbiAgcGFkZGluZzogMjBweCAxMHB4O1xyXG4gIGJvcmRlci1ib3R0b206IHNvbGlkIDFweCAjY2NjO1xyXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODcpO1xyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcclxuICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcclxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG4gIGN1cnNvcjogbW92ZTtcclxuICBiYWNrZ3JvdW5kOiB3aGl0ZTtcclxuICBmb250LXNpemU6IDE0cHg7XHJcbn1cclxuXHJcbi5jZGstZHJhZy1wcmV2aWV3IHtcclxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcclxuICBib3gtc2hhZG93OiAwIDVweCA1cHggLTNweCByZ2JhKDAsIDAsIDAsIDAuMiksIDAgOHB4IDEwcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4xNCksIDAgM3B4IDE0cHggMnB4IHJnYmEoMCwgMCwgMCwgMC4xMik7XHJcbn1cclxuXHJcbi5jZGstZHJhZy1wbGFjZWhvbGRlciB7XHJcbiAgb3BhY2l0eTogMDtcclxufVxyXG5cclxuLmNkay1kcmFnLWFuaW1hdGluZyB7XHJcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDI1MG1zIGN1YmljLWJlemllcigwLCAwLCAwLjIsIDEpO1xyXG59XHJcblxyXG4uZXhhbXBsZS1ib3g6bGFzdC1jaGlsZCB7XHJcbiAgYm9yZGVyOiBub25lO1xyXG59XHJcblxyXG4uZXhhbXBsZS1saXN0LmNkay1kcm9wLWxpc3QtZHJhZ2dpbmcgLmV4YW1wbGUtYm94Om5vdCguY2RrLWRyYWctcGxhY2Vob2xkZXIpIHtcclxuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMjUwbXMgY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMSk7XHJcbn1cclxuXHJcbi5leGFtcGxlLWJveC1iYXNpYzphY3RpdmUge1xyXG4gIGJveC1zaGFkb3c6IDAgNXB4IDVweCAtM3B4IHJnYmEoMCwgMCwgMCwgMC4yKSwgMCA4cHggMTBweCAxcHggcmdiYSgwLCAwLCAwLCAwLjE0KSwgMCAzcHggMTRweCAycHggcmdiYSgwLCAwLCAwLCAwLjEyKTtcclxufVxyXG5cclxuLmV4YW1wbGUtYm94LWJhc2ljIHtcclxuICB3aWR0aDogMjAwcHg7XHJcbiAgaGVpZ2h0OiAyMDBweDtcclxuICBib3JkZXI6IHNvbGlkIDFweCAjY2NjO1xyXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODcpO1xyXG4gIGN1cnNvcjogbW92ZTtcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gIGJhY2tncm91bmQ6ICNmZmY7XHJcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xyXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICB6LWluZGV4OiAxO1xyXG4gIHRyYW5zaXRpb246IGJveC1zaGFkb3cgMjAwbXMgY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMSk7XHJcbiAgYm94LXNoYWRvdzogMCAzcHggMXB4IC0ycHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwIDJweCAycHggMCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDFweCA1cHggMCByZ2JhKDAsIDAsIDAsIDAuMTIpO1xyXG59XHJcbiIsIi5leGFtcGxlLWNvbnRhaW5lciB7XG4gIHdpZHRoOiA0MDBweDtcbiAgbWF4LXdpZHRoOiAxMDAlO1xuICBtYXJnaW46IDAgMjVweCAyNXB4IDA7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgdmVydGljYWwtYWxpZ246IHRvcDtcbn1cblxuLmV4YW1wbGUtbGlzdCB7XG4gIGJvcmRlcjogc29saWQgMXB4ICNjY2M7XG4gIG1pbi1oZWlnaHQ6IDYwcHg7XG4gIGJhY2tncm91bmQ6IHdoaXRlO1xuICBib3JkZXItcmFkaXVzOiA0cHg7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIGRpc3BsYXk6IGJsb2NrO1xufVxuXG4uZXhhbXBsZS1ib3gge1xuICBwYWRkaW5nOiAyMHB4IDEwcHg7XG4gIGJvcmRlci1ib3R0b206IHNvbGlkIDFweCAjY2NjO1xuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjg3KTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBjdXJzb3I6IG1vdmU7XG4gIGJhY2tncm91bmQ6IHdoaXRlO1xuICBmb250LXNpemU6IDE0cHg7XG59XG5cbi5jZGstZHJhZy1wcmV2aWV3IHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xuICBib3gtc2hhZG93OiAwIDVweCA1cHggLTNweCByZ2JhKDAsIDAsIDAsIDAuMiksIDAgOHB4IDEwcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4xNCksIDAgM3B4IDE0cHggMnB4IHJnYmEoMCwgMCwgMCwgMC4xMik7XG59XG5cbi5jZGstZHJhZy1wbGFjZWhvbGRlciB7XG4gIG9wYWNpdHk6IDA7XG59XG5cbi5jZGstZHJhZy1hbmltYXRpbmcge1xuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMjUwbXMgY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMSk7XG59XG5cbi5leGFtcGxlLWJveDpsYXN0LWNoaWxkIHtcbiAgYm9yZGVyOiBub25lO1xufVxuXG4uZXhhbXBsZS1saXN0LmNkay1kcm9wLWxpc3QtZHJhZ2dpbmcgLmV4YW1wbGUtYm94Om5vdCguY2RrLWRyYWctcGxhY2Vob2xkZXIpIHtcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDI1MG1zIGN1YmljLWJlemllcigwLCAwLCAwLjIsIDEpO1xufVxuXG4uZXhhbXBsZS1ib3gtYmFzaWM6YWN0aXZlIHtcbiAgYm94LXNoYWRvdzogMCA1cHggNXB4IC0zcHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwIDhweCAxMHB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwIDNweCAxNHB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMTIpO1xufVxuXG4uZXhhbXBsZS1ib3gtYmFzaWMge1xuICB3aWR0aDogMjAwcHg7XG4gIGhlaWdodDogMjAwcHg7XG4gIGJvcmRlcjogc29saWQgMXB4ICNjY2M7XG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODcpO1xuICBjdXJzb3I6IG1vdmU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIGJhY2tncm91bmQ6ICNmZmY7XG4gIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB6LWluZGV4OiAxO1xuICB0cmFuc2l0aW9uOiBib3gtc2hhZG93IDIwMG1zIGN1YmljLWJlemllcigwLCAwLCAwLjIsIDEpO1xuICBib3gtc2hhZG93OiAwIDNweCAxcHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMiksIDAgMnB4IDJweCAwIHJnYmEoMCwgMCwgMCwgMC4xNCksIDAgMXB4IDVweCAwIHJnYmEoMCwgMCwgMCwgMC4xMik7XG59Il19 */\"","import { Component, OnInit } from '@angular/core';\r\nimport { CdkDragDrop, moveItemInArray, transferArrayItem } from '@angular/cdk/drag-drop';\r\n\r\n@Component({\r\n  selector: 'app-mat-drag-drop',\r\n  templateUrl: './mat-drag-drop.page.html',\r\n  styleUrls: ['./mat-drag-drop.page.scss'],\r\n})\r\nexport class MatDragDropPage implements OnInit {\r\n\r\n  todo = [\r\n    'Get to work',\r\n    'Pick up groceries',\r\n    'Go home',\r\n    'Fall asleep'\r\n  ];\r\n\r\n  done = [\r\n    'Get up',\r\n    'Brush teeth',\r\n    'Take a shower',\r\n    'Check e-mail',\r\n    'Walk dog'\r\n  ];\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit() {\r\n  }\r\n\r\n  drop(event: CdkDragDrop<string[]>) {\r\n    if (event.previousContainer === event.container) {\r\n      moveItemInArray(event.container.data, event.previousIndex, event.currentIndex);\r\n    } else {\r\n      transferArrayItem(event.previousContainer.data,\r\n        event.container.data,\r\n        event.previousIndex,\r\n        event.currentIndex);\r\n    }\r\n  }\r\n\r\n}\r\n"]}